{
  "then": {
    "and": "Applies a custom function to modify a `Then` instance, enhancing flexibility and readability\nin setting up mock server responses.\n\nThis method allows you to encapsulate complex configurations into reusable functions,\nand apply them without breaking the chain of method calls on a `Then` object.\n\n# Parameters\n- `func`: A function that takes a `Then` instance and returns it after applying some modifications.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Then` object.\n\n# Example\nDemonstrates how to use the `and` method to maintain readability while applying multiple\nmodifications from an external function.\n\n```rust\nuse std::time::Duration;\nuse http::{StatusCode, header::HeaderValue};\nuse httpmock::{Then, MockServer};\n\n// Function that configures a response with JSON content and a delay\nfn ok_json_with_delay(then: Then) -> Then {\n    then.status(StatusCode::OK.as_u16())\n        .header(\"content-type\", \"application/json\")\n        .delay(Duration::from_secs_f32(0.5))\n}\n\n// Usage within a method chain\nlet server = MockServer::start();\nlet then = server.mock(|when, then| {\n    when.path(\"/example\");\n    then.header(\"general-vibe\", \"much better\")\n        .and(ok_json_with_delay);\n});\n\n// The `and` method keeps the setup intuitively readable as a continuous chain\n```\n",
    "body": "Configures the HTTP response body that the mock server will return.\n\n# Parameters\n- `body`: The content of the response body, provided as a type that can be referenced as a byte slice.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Mock` object.\n\n# Example\nDemonstrates setting a response body for a request to the path `/hello` with a 200 OK status.\n\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Initialize the mock server\nlet server = MockServer::start();\n\n// Configure the mock\nlet m = server.mock(|when, then| {\n    when.path(\"/hello\");\n    then.status(200)\n        .body(\"ohi!\");\n});\n\n// Send a request and verify the response\nlet response = Client::new()\n    .get(server.url(\"/hello\"))\n    .send()\n    .unwrap();\n\n// Check that the mock was called as expected and the response body is as configured\nm.assert();\nassert_eq!(response.status(), 200);\nassert_eq!(response.text().unwrap(), \"ohi!\");\n```\n",
    "body_from_file": "Configures the HTTP response body with content loaded from a specified file on the mock server.\n\n# Parameters\n- `resource_file_path`: A string representing the path to the file whose contents will be used as the response body. The path can be absolute or relative to the server's running directory.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Mock` object.\n\n# Panics\nPanics if the specified file cannot be read, or if the path provided cannot be resolved to an absolute path.\n\n# Example\nDemonstrates setting the response body from a file for a request to the path `/hello` with a 200 OK status.\n\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Initialize the mock server\nlet server = MockServer::start();\n\n// Configure the mock\nlet m = server.mock(|when, then| {\n    when.path(\"/hello\");\n    then.status(200)\n        .body_from_file(\"tests/resources/simple_body.txt\");\n});\n\n// Send a request and verify the response\nlet response = Client::new()\n    .get(server.url(\"/hello\"))\n    .send()\n    .unwrap();\n\n// Check that the mock was called as expected and the response body matches the file contents\nm.assert();\nassert_eq!(response.status(), 200);\nassert_eq!(response.text().unwrap(), \"ohi!\");\n```\n",
    "delay": "Sets a delay for the mock server response.\n\nThis method configures the server to wait for a specified duration before sending a response,\nwhich can be useful for testing timeout scenarios or asynchronous operations.\n\n# Parameters\n- `duration`: The length of the delay as a `std::time::Duration`.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Mock` object.\n\n# Panics\nPanics if the specified duration results in a delay that cannot be represented as a 64-bit\nunsigned integer of milliseconds (more than approximately 584 million years).\n\n# Example\nDemonstrates setting a 3-second delay for a request to the path `/delay`.\n\n```rust\nuse std::time::{SystemTime, Duration};\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet _ = env_logger::try_init();\nlet start_time = SystemTime::now();\nlet three_seconds = Duration::from_secs(3);\nlet server = MockServer::start();\n\n// Configure the mock\nlet mock = server.mock(|when, then| {\n    when.path(\"/delay\");\n    then.status(200)\n        .delay(three_seconds);\n});\n\n// Act\nlet response = Client::new()\n    .get(server.url(\"/delay\"))\n    .send()\n    .unwrap();\n\n// Assert\nmock.assert();\nassert!(start_time.elapsed().unwrap() >= three_seconds);\n```\n",
    "header": "Sets an HTTP header that the mock server will return in the response.\n\nThis method configures a response header to be included when the mock server handles a request.\n\n# Parameters\n- `name`: The name of the header to set.\n- `value`: The value of the header.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Mock` object.\n\n# Example\nDemonstrates setting the \"Expires\" header for a response to a request to the root path.\n\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet _ = env_logger::try_init();\nlet server = MockServer::start();\n\n// Configure the mock\nlet m = server.mock(|when, then| {\n    when.path(\"/\");\n    then.status(200)\n        .header(\"Expires\", \"Wed, 21 Oct 2050 07:28:00 GMT\");\n});\n\n// Act\nlet response = Client::new()\n    .get(server.url(\"/\"))\n    .send()\n    .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 200);\nassert_eq!(\n    response.headers().get(\"Expires\").unwrap().to_str().unwrap(),\n    \"Wed, 21 Oct 2050 07:28:00 GMT\"\n);\n```\n",
    "json_body": "Sets the JSON body for the HTTP response that will be returned by the mock server.\n\nThis function accepts a JSON object that must be serializable and deserializable by serde.\nNote that this method does not automatically set the \"Content-Type\" header to \"application/json\".\nYou will need to set this header manually if required.\n\n# Parameters\n- `body`: The HTTP response body in the form of a `serde_json::Value` object.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Mock` object.\n\n# Example\nDemonstrates how to set a JSON body and a matching \"Content-Type\" header for a mock response.\n\n```rust\nuse httpmock::prelude::*;\nuse serde_json::{Value, json};\nuse reqwest::blocking::Client;\n\n// Arrange\nlet _ = env_logger::try_init();\nlet server = MockServer::start();\n\n// Configure the mock\nlet m = server.mock(|when, then| {\n    when.path(\"/user\");\n    then.status(200)\n        .header(\"content-type\", \"application/json\")\n        .json_body(json!({ \"name\": \"Hans\" }));\n});\n\n// Act\nlet response = Client::new()\n    .get(server.url(\"/user\"))\n    .send()\n    .unwrap();\n\n// Get the status code first\nlet status = response.status();\n\n// Extract the text from the response\nlet response_text = response.text().unwrap();\n\n// Deserialize the JSON response\nlet user: Value =\n    serde_json::from_str(&response_text).expect(\"cannot deserialize JSON\");\n\n// Assert\nm.assert();\nassert_eq!(status, 200);\nassert_eq!(user[\"name\"], \"Hans\");\n```\n",
    "json_body_obj": "Sets the JSON body that will be returned by the mock server using a serializable serde object.\n\nThis method converts the provided object into a JSON string. It does not automatically set\nthe \"Content-Type\" header to \"application/json\", so you must set this header manually if it's\nneeded.\n\n# Parameters\n- `body`: A reference to an object that implements the `serde::Serialize` trait.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Mock` object.\n\n# Panics\nPanics if the object cannot be serialized into a JSON string.\n\n# Example\nDemonstrates setting a JSON body and the corresponding \"Content-Type\" header for a user object.\n\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct TestUser {\n    name: String,\n}\n\n// Arrange\nlet _ = env_logger::try_init();\nlet server = MockServer::start();\n\n// Configure the mock\nlet m = server.mock(|when, then| {\n    when.path(\"/user\");\n    then.status(200)\n        .header(\"content-type\", \"application/json\")\n        .json_body_obj(&TestUser {\n            name: String::from(\"Hans\"),\n        });\n});\n\n// Act\nlet response = Client::new()\n    .get(server.url(\"/user\"))\n    .send()\n    .unwrap();\n\n// Get the status code first\nlet status = response.status();\n\n// Extract the text from the response\nlet response_text = response.text().unwrap();\n\n// Deserialize the JSON response into a TestUser object\nlet user: TestUser =\n    serde_json::from_str(&response_text).unwrap();\n\n// Assert\nm.assert();\nassert_eq!(status, 200);\nassert_eq!(user.name, \"Hans\");\n```\n",
    "status": "Configures the HTTP response status code that the mock server will return.\n\n# Parameters\n- `status`: A `u16` HTTP status code that the mock server should return for the configured request.\n\n# Returns\nReturns `self` to allow chaining of method calls on the `Mock` object.\n\n# Example\nDemonstrates setting a 200 OK status for a request to the path `/hello`.\n\n```rust\nuse httpmock::prelude::*;\n\n// Initialize the mock server\nlet server = MockServer::start();\n\n// Configure the mock\nlet m = server.mock(|when, then| {\n    when.path(\"/hello\");\n    then.status(200);\n});\n\n// Send a request and verify the response\nlet response = reqwest::blocking::get(server.url(\"/hello\")).unwrap();\n\n// Check that the mock was called as expected and the response status is as configured\nm.assert();\nassert_eq!(response.status(), 200);\n```\n"
  },
  "when": {
    "and": "Applies a specified function to enhance or modify the `When` instance. This method allows for the\nencapsulation of multiple matching conditions into a single function, maintaining a clear and fluent\ninterface for setting up HTTP request expectations.\n\nThis method is particularly useful for reusing common setup patterns across multiple test scenarios,\npromoting cleaner and more maintainable test code.\n\n# Parameters\n- `func`: A function that takes a `When` instance and returns it after applying some conditions.\n\n## Example\n```rust\nuse httpmock::{prelude::*, When};\nuse httpmock::Method::POST;\n\n// Function to apply a standard authorization and content type setup for JSON POST requests\nfn is_authorized_json_post_request(when: When) -> When {\n    when.method(POST)\n        .header(\"Authorization\", \"SOME API KEY\")\n        .header(\"Content-Type\", \"application/json\")\n}\n\n// Usage example demonstrating how to maintain fluent interface style with complex setups.\n// This approach keeps the chain of conditions clear and readable, enhancing test legibility\nlet server = MockServer::start();\nlet m = server.mock(|when, then| {\n    when.query_param(\"user_id\", \"12345\")\n        .and(is_authorized_json_post_request) // apply the function to include common setup\n        .json_body_includes(r#\"{\"key\": \"value\"}\"#); // additional specific condition\n    then.status(200);\n});\n```\n\n# Returns\n`When`: The modified `When` instance with additional conditions applied, suitable for further chaining.\n",
    "any_request": "Configures the mock server to respond to any incoming request, regardless of the URL path,\nquery parameters, headers, or method.\n\nThis method doesn't directly alter the behavior of the mock server, as it already responds to any\nrequest by default. However, it serves as an explicit indication in your code that the\nserver will respond to any request.\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Configure the mock server to respond to any request\nlet mock = server.mock(|when, then| {\n    when.any_request();  // Explicitly specify that any request should match\n    then.status(200);    // Respond with status code 200 for all matched requests\n});\n\n// Make a request to the server's URL and ensure the mock is triggered\nlet response = reqwest::blocking::get(server.url(\"/anyPath\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Assert that the mock was called at least once\nmock.assert();\n```\n\n# Note\nThis is the default behavior as of now, but it may change in future versions.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "body": "Sets the required HTTP request body content.\nThis method specifies that the HTTP request body must match the provided content exactly.\n\n**Note**: The body content is case-sensitive and must be an exact match.\n\n# Parameters\n- `body`: The required HTTP request body content. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to be \"The Great Gatsby\"\nlet mock = server.mock(|when, then| {\n    when.body(\"The Great Gatsby\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with the required body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"The Great Gatsby\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "body_excludes": "Sets the condition that the HTTP request body content must not contain the specified substring.\nThis method ensures that the request body does not include the provided content as a substring.\n\n**Note**: The body content is case-sensitive.\n\n# Parameters\n- `substring`: The substring that the HTTP request body must not contain. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to not contain the substring \"Gatsby\"\nlet mock = server.mock(|when, then| {\n    when.body_excludes(\"Gatsby\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with a different body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"A Tale of Two Cities is a novel.\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "body_includes": "Sets the condition that the HTTP request body content must contain the specified substring.\nThis method ensures that the request body includes the provided content as a substring.\n\n**Note**: The body content is case-sensitive.\n\n# Parameters\n- `substring`: The substring that the HTTP request body must contain. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to contain the substring \"Gatsby\"\nlet mock = server.mock(|when, then| {\n    when.body_includes(\"Gatsby\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with the required substring in the body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"The Great Gatsby is a novel.\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "body_matches": "Sets the condition that the HTTP request body content must match the specified regular expression.\nThis method ensures that the request body fully conforms to the provided regex pattern.\n\n**Note**: The regex matching is case-sensitive unless the regex is explicitly defined to be case-insensitive.\n\n# Parameters\n- `pattern`: The regular expression pattern that the HTTP request body must match. This parameter accepts any type that can be converted into a `Regex`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to match the regex pattern \"^The Great Gatsby.*\"\nlet mock = server.mock(|when, then| {\n    when.body_matches(\"^The Great Gatsby.*\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with a body that matches the regex pattern\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"The Great Gatsby is a novel by F. Scott Fitzgerald.\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When’ instance to allow method chaining for additional configuration.\n",
    "body_not": "Sets the condition that the HTTP request body content must not match the specified value.\nThis method ensures that the request body does not contain the provided content exactly.\n\n**Note**: The body content is case-sensitive and must be an exact mismatch.\n\n# Parameters\n- `body`: The body content that the HTTP request must not contain. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to not be \"The Great Gatsby\"\nlet mock = server.mock(|when, then| {\n    when.body_not(\"The Great Gatsby\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with a different body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"A Tale of Two Cities\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "body_prefix": "Sets the condition that the HTTP request body content must begin with the specified substring.\nThis method ensures that the request body starts with the provided content as a substring.\n\n**Note**: The body content is case-sensitive.\n\n# Parameters\n- `prefix`: The substring that the HTTP request body must begin with. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to begin with the substring \"The Great\"\nlet mock = server.mock(|when, then| {\n    when.body_prefix(\"The Great\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with the required prefix in the body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"The Great Gatsby is a novel.\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "body_prefix_not": "Sets the condition that the HTTP request body content must not begin with the specified substring.\nThis method ensures that the request body does not start with the provided content as a substring.\n\n**Note**: The body content is case-sensitive.\n\n# Parameters\n- `prefix`: The substring that the HTTP request body must not begin with. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to not begin with the substring \"Error:\"\nlet mock = server.mock(|when, then| {\n    when.body_prefix_not(\"Error:\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with a different body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"Success: Operation completed.\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When’ instance to allow method chaining for additional configuration.\n",
    "body_suffix": "Sets the condition that the HTTP request body content must end with the specified substring.\nThis method ensures that the request body concludes with the provided content as a substring.\n\n**Note**: The body content is case-sensitive.\n\n# Parameters\n- `suffix`: The substring that the HTTP request body must end with. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to end with the substring \"a novel.\"\nlet mock = server.mock(|when, then| {\n    when.body_suffix(\"a novel.\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with the required suffix in the body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"The Great Gatsby is a novel.\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When’ instance to allow method chaining for additional configuration.\n",
    "body_suffix_not": "Sets the condition that the HTTP request body content must not end with the specified substring.\nThis method ensures that the request body does not conclude with the provided content as a substring.\n\n**Note**: The body content is case-sensitive.\n\n# Parameters\n- `suffix`: The substring that the HTTP request body must not end with. This parameter accepts any type that can be converted into a `String`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to not end with the substring \"a novel.\"\nlet mock = server.mock(|when, then| {\n    when.body_suffix_not(\"a novel.\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with a different body content\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .body(\"The Great Gatsby is a story.\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When’ instance to allow method chaining for additional configuration.\n",
    "cookie": "Sets the cookie that needs to exist in the HTTP request.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie. Must be a case-sensitive match.\n- `value`: The expected value of the cookie.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" with the value \"1234567890\"\nlet mock = server.mock(|when, then| {\n    when.cookie(\"SESSIONID\", \"1234567890\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234567890; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_count": "Sets the requirement that a cookie with a name and value matching the specified regexes must appear a specified number of times in the HTTP request.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `key_regex`: The regex pattern that the cookie name must match.\n- `value_regex`: The regex pattern that the cookie value must match.\n- `count`: The number of times a cookie with a matching name and value must appear.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie with a name matching the regex \"^SESSION\"\n// and a value matching the regex \"^[0-9]{10}$\" to appear exactly twice\nlet mock = server.mock(|when, then| {\n    when.cookie_count(r\"^SESSION\", r\"^[0-9]{10}$\", 2);\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookies\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"SESSIONID=1234567890; TRACK=12345; SESSIONTOKEN=0987654321; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_excludes": "Sets the requirement that a cookie with the specified name must exist and its value must not contain the specified substring.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must exist.\n- `value_substring`: The substring that must not be present in the cookie value.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" with a value not containing \"1234\"\nlet mock = server.mock(|when, then| {\n    when.cookie_excludes(\"SESSIONID\", \"1234\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcdef; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_exists": "Sets the requirement that a cookie with the specified name must exist in the HTTP request.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must exist.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\"\nlet mock = server.mock(|when, then| {\n    when.cookie_exists(\"SESSIONID\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234567890; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_includes": "Sets the requirement that a cookie with the specified name must exist and its value must contain the specified substring.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must exist.\n- `value_substring`: The substring that must be present in the cookie value.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" with a value containing \"1234\"\nlet mock = server.mock(|when, then| {\n    when.cookie_includes(\"SESSIONID\", \"1234\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=abc1234def; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_matches": "Sets the requirement that a cookie with a name matching the specified regex must exist and its value must match the specified regex.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `key_regex`: The regex pattern that the cookie name must match.\n- `value_regex`: The regex pattern that the cookie value must match.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie with a name matching the regex \"^SESSION\"\n// and a value matching the regex \"^[0-9]{10}$\"\nlet mock = server.mock(|when, then| {\n    when.cookie_matches(r\"^SESSION\", r\"^[0-9]{10}$\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234567890; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_missing": "Sets the requirement that a cookie with the specified name must not exist in the HTTP request.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must not exist.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" not to exist\nlet mock = server.mock(|when, then| {\n    when.cookie_missing(\"SESSIONID\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that does not include the excluded cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_not": "Sets the cookie that should not exist or should not have a specific value in the HTTP request.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie. Must be a case-sensitive match.\n- `value`: The value that the cookie should not have.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" to not have the value \"1234567890\"\nlet mock = server.mock(|when, then| {\n    when.cookie_not(\"SESSIONID\", \"1234567890\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=0987654321; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_prefix": "Sets the requirement that a cookie with the specified name must exist and its value must start with the specified substring.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must exist.\n- `value_prefix`: The substring that must be at the start of the cookie value.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" with a value starting with \"1234\"\nlet mock = server.mock(|when, then| {\n    when.cookie_prefix(\"SESSIONID\", \"1234\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234abcdef; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_prefix_not": "Sets the requirement that a cookie with the specified name must exist and its value must not start with the specified substring.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must exist.\n- `value_prefix`: The substring that must not be at the start of the cookie value.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" with a value not starting with \"1234\"\nlet mock = server.mock(|when, then| {\n    when.cookie_prefix_not(\"SESSIONID\", \"1234\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcd1234; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_suffix": "Sets the requirement that a cookie with the specified name must exist and its value must end with the specified substring.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must exist.\n- `value_suffix`: The substring that must be at the end of the cookie value.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" with a value ending with \"7890\"\nlet mock = server.mock(|when, then| {\n    when.cookie_suffix(\"SESSIONID\", \"7890\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcdef7890; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "cookie_suffix_not": "Sets the requirement that a cookie with the specified name must exist and its value must not end with the specified substring.\nCookie parsing follows [RFC-6265](https://tools.ietf.org/html/rfc6265.html).\n**Attention**: Cookie names are **case-sensitive**.\n\n# Parameters\n- `name`: The name of the cookie that must exist.\n- `value_suffix`: The substring that must not be at the end of the cookie value.\n\n> Note: This function is only available when the `cookies` feature is enabled. This feature is enabled by default.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects a cookie named \"SESSIONID\" with a value not ending with \"7890\"\nlet mock = server.mock(|when, then| {\n    when.cookie_suffix_not(\"SESSIONID\", \"7890\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required cookie\n Client::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcdef1234; CONSENT=1\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "form_urlencoded_tuple": "Adds a key-value pair to the requirements for an `application/x-www-form-urlencoded` request body.\n\nThis method sets an expectation for a specific key-value pair to be included in the request body\nof an `application/x-www-form-urlencoded` POST request. Each key and value are URL-encoded as specified\nby the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key of the key-value pair to set as a requirement.\n- `value`: The value of the key-value pair to set as a requirement.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple(\"name\", \"Peter Griffin\")\n       .form_urlencoded_tuple(\"town\", \"Quahog\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value pair added to the `application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_count": "Sets a requirement for the number of times a key-value pair matching specific regular expressions appears in an `application/x-www-form-urlencoded` request body.\n\nThis method sets an expectation that the key-value pair must appear a specific number of times in the request body of an\n`application/x-www-form-urlencoded` POST request. The key and value regular expressions are URL-encoded as specified by the\n[URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key_regex`: The regular expression that the key must match in the `application/x-www-form-urlencoded` request body.\n- `value_regex`: The regular expression that the value must match in the `application/x-www-form-urlencoded` request body.\n- `count`: The number of times the key-value pair matching the regular expressions must appear.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\nuse regex::Regex;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_count(\n           Regex::new(r\"^name$\").unwrap(),\n           Regex::new(r\".*Griffin$\").unwrap(),\n           2\n       );\n   then.status(202);\n});\n\n// Act\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&name=Lois%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value count requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_excludes": "Sets a requirement that a key's value in an `application/x-www-form-urlencoded` request body must not contain a specific substring.\n\nThis method sets an expectation that the value associated with a specific key must not contain a specified substring\nin the request body of an `application/x-www-form-urlencoded` POST request. The key and the substring are URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key in the `application/x-www-form-urlencoded` request body.\n- `substring`: The substring that must not be present in the value associated with the key.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_excludes(\"name\", \"Griffin\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Lois%20Smith&city=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value substring exclusion requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_exists": "Sets a requirement for the existence of a key in an `application/x-www-form-urlencoded` request body.\n\nThis method sets an expectation that a specific key must be present in the request body of an\n`application/x-www-form-urlencoded` POST request, regardless of its value. The key is URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key that must exist in the `application/x-www-form-urlencoded` request body.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_exists(\"name\")\n       .form_urlencoded_tuple_exists(\"town\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key existence requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_includes": "Sets a requirement that a key's value in an `application/x-www-form-urlencoded` request body must contain a specific substring.\n\nThis method sets an expectation that the value associated with a specific key must contain a specified substring\nin the request body of an `application/x-www-form-urlencoded` POST request. The key and the substring are URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key in the `application/x-www-form-urlencoded` request body.\n- `substring`: The substring that must be present in the value associated with the key.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_includes(\"name\", \"Griffin\")\n       .form_urlencoded_tuple_includes(\"town\", \"Quahog\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value substring requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_matches": "Sets a requirement that a key-value pair in an `application/x-www-form-urlencoded` request body must match specific regular expressions.\n\nThis method sets an expectation that the key and the value in a key-value pair must match the specified regular expressions\nin the request body of an `application/x-www-form-urlencoded` POST request. The key and value regular expressions are URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key_regex`: The regular expression that the key must match in the `application/x-www-form-urlencoded` request body.\n- `value_regex`: The regular expression that the value must match in the `application/x-www-form-urlencoded` request body.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\nuse regex::Regex;\n\n// Arrange\nlet server = MockServer::start();\n\nlet key_regex = Regex::new(r\"^name$\").unwrap();\nlet value_regex = Regex::new(r\"^Peter\\sGriffin$\").unwrap();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_matches(key_regex, value_regex);\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value regex matching requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_missing": "Sets a requirement that a key must be absent in an `application/x-www-form-urlencoded` request body.\n\nThis method sets an expectation that a specific key must not be present in the request body of an\n`application/x-www-form-urlencoded` POST request. The key is URL-encoded as specified by the\n[URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key that must be absent in the `application/x-www-form-urlencoded` request body.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_missing(\"name\")\n       .form_urlencoded_tuple_missing(\"town\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"city=Quahog&occupation=Cartoonist\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key absence requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_not": "Adds a key-value pair to the negative requirements for an `application/x-www-form-urlencoded` request body.\n\nThis method sets an expectation for a specific key-value pair to be excluded from the request body\nof an `application/x-www-form-urlencoded` POST request. Each key and value are URL-encoded as specified\nby the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key of the key-value pair to set as a requirement.\n- `value`: The value of the key-value pair to set as a requirement.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_not(\"name\", \"Peter Griffin\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Lois%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value pair added to the negative `application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_prefix": "Sets a requirement that a key's value in an `application/x-www-form-urlencoded` request body must start with a specific prefix.\n\nThis method sets an expectation that the value associated with a specific key must start with a specified prefix\nin the request body of an `application/x-www-form-urlencoded` POST request. The key and the prefix are URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key in the `application/x-www-form-urlencoded` request body.\n- `prefix`: The prefix that must appear at the start of the value associated with the key.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_prefix(\"name\", \"Pete\")\n       .form_urlencoded_tuple_prefix(\"town\", \"Qua\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value prefix requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_prefix_not": "Sets a requirement that a key's value in an `application/x-www-form-urlencoded` request body must not start with a specific prefix.\n\nThis method sets an expectation that the value associated with a specific key must not start with a specified prefix\nin the request body of an `application/x-www-form-urlencoded` POST request. The key and the prefix are URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key in the `application/x-www-form-urlencoded` request body.\n- `prefix`: The prefix that must not appear at the start of the value associated with the key.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_prefix_not(\"name\", \"Lois\")\n       .form_urlencoded_tuple_prefix_not(\"town\", \"Hog\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value prefix exclusion requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_suffix": "Sets a requirement that a key's value in an `application/x-www-form-urlencoded` request body must end with a specific suffix.\n\nThis method sets an expectation that the value associated with a specific key must end with a specified suffix\nin the request body of an `application/x-www-form-urlencoded` POST request. The key and the suffix are URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key in the `application/x-www-form-urlencoded` request body.\n- `suffix`: The suffix that must appear at the end of the value associated with the key.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_suffix(\"name\", \"Griffin\")\n       .form_urlencoded_tuple_suffix(\"town\", \"hog\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value suffix requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "form_urlencoded_tuple_suffix_not": "Sets a requirement that a key's value in an `application/x-www-form-urlencoded` request body must not end with a specific suffix.\n\nThis method sets an expectation that the value associated with a specific key must not end with a specified suffix\nin the request body of an `application/x-www-form-urlencoded` POST request. The key and the suffix are URL-encoded\nas specified by the [URL Standard](https://url.spec.whatwg.org/#application/x-www-form-urlencoded).\n\n**Note**: The mock server does not automatically verify that the HTTP method is POST as per spec.\nIf you want to verify that the request method is POST, you must explicitly set it in your mock configuration.\n\n# Parameters\n- `key`: The key in the `application/x-www-form-urlencoded` request body.\n- `suffix`: The suffix that must not appear at the end of the value associated with the key.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.method(POST)\n       .path(\"/example\")\n       .header(\"content-type\", \"application/x-www-form-urlencoded\")\n       .form_urlencoded_tuple_suffix_not(\"name\", \"Smith\")\n       .form_urlencoded_tuple_suffix_not(\"town\", \"ville\");\n   then.status(202);\n});\n\nlet response = Client::new()\n   .post(server.url(\"/example\"))\n   .header(\"content-type\", \"application/x-www-form-urlencoded\")\n   .body(\"name=Peter%20Griffin&town=Quahog\")\n   .send()\n   .unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 202);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new key-value suffix exclusion requirement added to the\n`application/x-www-form-urlencoded` expectations.\n",
    "header": "Sets the expected HTTP header and its value for the request to match.\nThis function ensures that the specified header with the given value is present in the request.\nHeader names are case-insensitive, as per RFC 2616.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `value`: The expected value of the HTTP header.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header with a specific value\nlet mock = server.mock(|when, then| {\n    when.header(\"Authorization\", \"token 1234567890\");\n    then.status(200);  // Respond with a 200 status code if the header and value are present\n});\n\n// Make a request that includes the \"Authorization\" header with the specified value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_count": "Sets the requirement that the HTTP request must contain a specific number of headers whose keys and values match specified patterns.\nThis function ensures that the specified number of headers with keys and values matching the given patterns are present in the request.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple patterns and counts.\n\n# Parameters\n- `key_pattern`: The pattern that the header keys must match.\n- `value_pattern`: The pattern that the header values must match.\n- `count`: The number of headers with keys and values matching the patterns that must be present.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects at least 2 headers whose keys match the regex \"^X-Custom-Header.*\"\n// and values match the regex \"value.*\"\nlet mock = server.mock(|when, then| {\n    when.header_count(\"^X-Custom-Header.*\", \"value.*\", 2);\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request that includes the required headers\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"x-custom-header-1\", \"value1\")\n    .header(\"X-Custom-Header-2\", \"value2\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_excludes": "Sets the requirement that the HTTP request must contain a specific header whose value does not contain a specified substring.\nThis function ensures that the specified header is present and its value does not contain the given substring.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple headers and substrings.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `substring`: The substring that the header value must not contain.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header's value to not contain \"Bearer\"\nlet mock = server.mock(|when, then| {\n    when.header_excludes(\"Authorization\", \"Bearer\");\n    then.status(200);  // Respond with a 200 status code if the header value does not contain the substring\n});\n\n// Make a request that includes the \"Authorization\" header without the forbidden substring in its value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_exists": "Sets the requirement that the HTTP request must contain a specific header.\nThe presence of the header is checked, but its value is not validated.\nFor value validation, refer to [Mock::expect_header](struct.Mock.html#method.expect_header).\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive, as per RFC 2616.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header to be present in the request\nlet mock = server.mock(|when, then| {\n    when.header_exists(\"Authorization\");\n    then.status(200);  // Respond with a 200 status code if the header is present\n});\n\n// Make a request that includes the \"Authorization\" header\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_includes": "Sets the requirement that the HTTP request must contain a specific header whose value contains a specified substring.\nThis function ensures that the specified header is present and its value contains the given substring.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple headers and substrings.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `substring`: The substring that the header value must contain.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header's value to contain \"token\"\nlet mock = server.mock(|when, then| {\n    when.header_includes(\"Authorization\", \"token\");\n    then.status(200);  // Respond with a 200 status code if the header value contains the substring\n});\n\n// Make a request that includes the \"Authorization\" header with the specified substring in its value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_matches": "Sets the requirement that the HTTP request must contain a specific header whose key and value match the specified regular expressions.\nThis function ensures that the specified header is present and both its key and value match the given regular expressions.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple headers and patterns.\n\n# Parameters\n- `key_regex`: The regular expression that the header key must match.\n- `value_regex`: The regular expression that the header value must match.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header's key to match the regex \"^Auth.*\"\n// and its value to match the regex \"token .*\"\nlet mock = server.mock(|when, then| {\n    when.header_matches(\"^Auth.*\", \"token .*\");\n    then.status(200);  // Respond with a 200 status code if the header key and value match the patterns\n});\n\n// Make a request that includes the \"Authorization\" header with a value matching the regex\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_missing": "Sets the requirement that the HTTP request must not contain a specific header.\nThis function ensures that the specified header is absent in the request.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to add multiple excluded headers.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header to be absent in the request\nlet mock = server.mock(|when, then| {\n    when.header_missing(\"Authorization\");\n    then.status(200);  // Respond with a 200 status code if the header is absent\n});\n\n// Make a request that does not include the \"Authorization\" header\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_not": "Sets the requirement that the HTTP request must not contain a specific header with the specified value.\nThis function ensures that the specified header with the given value is absent in the request.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to add multiple excluded headers.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `value`: The value of the HTTP header that must not be present.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header with a specific value to be absent\nlet mock = server.mock(|when, then| {\n    when.header_not(\"Authorization\", \"token 1234567890\");\n    then.status(200);  // Respond with a 200 status code if the header and value are absent\n});\n\n// Make a request that includes the \"Authorization\" header with a different value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token abcdefg\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_prefix": "Sets the requirement that the HTTP request must contain a specific header whose value starts with a specified prefix.\nThis function ensures that the specified header is present and its value starts with the given prefix.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple headers and prefixes.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `prefix`: The prefix that the header value must start with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header's value to start with \"token\"\nlet mock = server.mock(|when, then| {\n    when.header_prefix(\"Authorization\", \"token\");\n    then.status(200);  // Respond with a 200 status code if the header value starts with the prefix\n});\n\n// Make a request that includes the \"Authorization\" header with the specified prefix in its value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_prefix_not": "Sets the requirement that the HTTP request must contain a specific header whose value does not start with a specified prefix.\nThis function ensures that the specified header is present and its value does not start with the given prefix.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple headers and prefixes.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `prefix`: The prefix that the header value must not start with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header's value to not start with \"Bearer\"\nlet mock = server.mock(|when, then| {\n    when.header_prefix_not(\"Authorization\", \"Bearer\");\n    then.status(200);  // Respond with a 200 status code if the header value does not start with the prefix\n});\n\n// Make a request that includes the \"Authorization\" header without the \"Bearer\" prefix in its value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_suffix": "Sets the requirement that the HTTP request must contain a specific header whose value ends with a specified suffix.\nThis function ensures that the specified header is present and its value ends with the given suffix.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple headers and suffixes.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `suffix`: The suffix that the header value must end with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header's value to end with \"7890\"\nlet mock = server.mock(|when, then| {\n    when.header_suffix(\"Authorization\", \"7890\");\n    then.status(200);  // Respond with a 200 status code if the header value ends with the suffix\n});\n\n// Make a request that includes the \"Authorization\" header with the specified suffix in its value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "header_suffix_not": "Sets the requirement that the HTTP request must contain a specific header whose value does not end with a specified suffix.\nThis function ensures that the specified header is present and its value does not end with the given suffix.\nHeader names are case-insensitive, as per RFC 2616.\n\nThis function may be called multiple times to check multiple headers and suffixes.\n\n# Parameters\n- `name`: The HTTP header name. Header names are case-insensitive.\n- `suffix`: The suffix that the header value must not end with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the \"Authorization\" header's value to not end with \"abc\"\nlet mock = server.mock(|when, then| {\n    when.header_suffix_not(\"Authorization\", \"abc\");\n    then.status(200);  // Respond with a 200 status code if the header value does not end with the suffix\n});\n\n// Make a request that includes the \"Authorization\" header without the \"abc\" suffix in its value\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Authorization\", \"token 1234567890\")\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "host": "Sets the expected host name. This constraint is especially useful when working with\nproxy or forwarding rules, but it can also be used to serve mocks (e.g., when using a mock\nserver as a proxy).\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: Both `localhost` and `127.0.0.1` are treated equally.\nIf the provided host is set to either `localhost` or `127.0.0.1`, it will match\nrequests containing either `localhost` or `127.0.0.1`.\n\n* `host` - The host name (should not include a port).\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\nlet server = MockServer::start();\n\nserver.mock(|when, then| {\n    when.host(\"github.com\");\n    then.body(\"This is a mock response\");\n});\n\nlet client = Client::builder()\n    .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n    .build()\n    .unwrap();\n\nlet response = client.get(\"http://github.com\").send().unwrap();\n\nassert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_excludes": "Adds a substring that must not be present within the request's host name for the mock server to respond.\n\nThis method ensures that the mock server does not respond to requests if the host name contains the specified substring.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple excluded substrings, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: This function does not automatically compare with pseudo names, like \"localhost\".\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that excludes any request where the host name contains \"www.google.com\"\nlet mock = server.mock(|when, then| {\n    when.host_excludes(\"www.google.com\");  // Exclude hosts containing \"www.google.com\"\n    then.status(200);                      // Respond with status code 200 for other matched requests\n});\n\n// Make a request to a URL whose host name will be \"localhost\" and trigger the mock\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `host`: A string or other type convertible to `String` that will be added as a substring to exclude from matching.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_includes": "Adds a substring to match within the request's host name.\n\nThis method ensures that the mock server only matches requests whose host name contains the specified substring.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple substrings, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: This function does not automatically compare with pseudo names, like \"localhost\".\n\n# Attention\nThis function does not automatically treat 127.0.0.1 like localhost.\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any request where the host name contains \"localhost\"\nlet mock = server.mock(|when, then| {\n    when.host_includes(\"0.0\");  // Only match hosts containing \"0.0\" (e.g., 127.0.0.1)\n    then.status(200);           // Respond with status code 200 for all matched requests\n});\n\n// Make a request to a URL whose host name is \"localhost\" to trigger the mock\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `host`: A string or other type convertible to `String` that will be added as a substring to match against the request's host name.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_matches": "Sets a regular expression pattern that the request's host name must match for the mock server to respond.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple patterns, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: This function does not automatically compare with pseudo names, like \"localhost\".\n\n# Parameters\n- `regex`: A regular expression pattern to match against the host name. Should be a valid regex string.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches requests where the host name is exactly \"localhost\"\nlet mock = server.mock(|when, then| {\n    when.host_matches(r\"^127.0.0.1$\");\n    then.status(200);\n});\n\n// Make a request with \"127.0.0.1\" as the host name to trigger the mock response.\nlet response = reqwest::blocking::get(server.url(\"/\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_not": "Sets the host name that should **NOT** be responded for.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple suffixes, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n* `host` - The host name (should not include a port).\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\nlet server = MockServer::start();\n\nserver.mock(|when, then| {\n    when.host(\"github.com\");\n    then.body(\"This is a mock response\");\n});\n\nlet client = Client::builder()\n    .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n    .build()\n    .unwrap();\n\nlet response = client.get(\"http://github.com\").send().unwrap();\n\nassert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_prefix": "Adds a prefix that the request's host name must start with for the mock server to respond.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple prefixes, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: This function does not automatically compare with pseudo names, like \"localhost\".\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any request where the host name starts with \"local\"\nlet mock = server.mock(|when, then| {\n    when.host_prefix(\"127.0\");      // Only match hosts starting with \"127.0\"\n    then.status(200);               // Respond with status code 200 for all matched requests\n});\n\n// Make a request to the mock server with a host name of \"127.0.0.1\" to trigger the mock response.\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `prefix`: A string or other type convertible to `String` specifying the prefix that the host name should start with.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_prefix_not": "Adds a prefix that the request's host name must *not* start with for the mock server to respond.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple excluded prefixes, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: This function does not automatically compare with pseudo names, like \"localhost\".\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any request where the host name does not start with \"www.\"\nlet mock = server.mock(|when, then| {\n    when.host_prefix_not(\"www.\");      // Exclude hosts starting with \"www\"\n    then.status(200);                  // Respond with status code 200 for all other requests\n});\n\n// Make a request with host name \"localhost\" that does not start with \"www\" and therefore\n// triggers the mock response.\nlet response = reqwest::blocking::get(server.url(\"/example\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `prefix`: A string or other type convertible to `String` specifying the prefix that the host name should *not* start with.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_suffix": "Adds a suffix that the request's host name must end with for the mock server to respond.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple suffixes, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: This function does not automatically compare with pseudo names, like \"localhost\".\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any request where the host name ends with \"host\" (e.g., \"localhost\").\nlet mock = server.mock(|when, then| {\n    when.host_suffix(\"0.1\");    // Only match hosts ending with \"0.1\"\n    then.status(200);           // Respond with status code 200 for all matched requests\n});\n\n// Make a request to the mock server with a host name of \"127.0.0.1\" to trigger the mock response.\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `host`: A string or other type convertible to `String` specifying the suffix that the host name should end with.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "host_suffix_not": "Adds a suffix that the request's host name must *not* end with for the mock server to respond.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple excluded suffixes, invoke this function multiple times.\n\n**Note**: Host matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\nThis standard dictates that all host names are treated equivalently, regardless of character case.\n\n**Note**: This function does not automatically compare with pseudo names, like \"localhost\".\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any request where the host name does not end with \"host\".\nlet mock = server.mock(|when, then| {\n    when.host_suffix_not(\"host\");   // Exclude hosts ending with \"host\"\n    then.status(200);               // Respond with status code 200 for all other requests\n});\n\n// Make a request with a host name that does not end with \"host\" to trigger the mock response.\nlet response = reqwest::blocking::get(server.url(\"/example\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `host`: A string or other type convertible to `String` specifying the suffix that the host name should *not* end with.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "is_false": "Adds a custom matcher for expected HTTP requests. If this function returns false, the request\nis considered a match, and the mock server will respond to the request\n(given all other criteria are also met).\n\nYou can use this function to create custom expectations for your mock server based on any aspect\nof the `HttpMockRequest` object.\n\n# Parameters\n- `matcher`: A function that takes a reference to an `HttpMockRequest` and returns a boolean indicating whether the request matches.\n\n## Example\n```rust\nuse httpmock::prelude::*;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.is_false(|req: &HttpMockRequest| {\n        req.uri().path().contains(\"es\")\n   });\n   then.status(404);\n});\n\n// Act: Send the HTTP request\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 404);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new custom matcher added to the expectations.\n",
    "is_true": "Adds a custom matcher for expected HTTP requests. If this function returns true, the request\nis considered a match, and the mock server will respond to the request\n(given all other criteria are also met).\n\nYou can use this function to create custom expectations for your mock server based on any aspect\nof the `HttpMockRequest` object.\n\n# Parameters\n- `matcher`: A function that takes a reference to an `HttpMockRequest` and returns a boolean indicating whether the request matches.\n\n## Example\n```rust\nuse httpmock::prelude::*;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.is_true(|req: &HttpMockRequest| {\n        req.uri().path().contains(\"es\")\n   });\n   then.status(200);\n});\n\n// Act: Send the HTTP request\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 200);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new custom matcher added to the expectations.\n",
    "json_body": "Sets the condition that the HTTP request body content must match the specified JSON structure.\nThis method ensures that the request body exactly matches the JSON value provided.\n\n**Note**: The body content is case-sensitive.\n\n**Note**: This method does not automatically verify the `Content-Type` header.\nIf specific content type verification is required (e.g., `application/json`),\nyou must add this expectation manually.\n\n# Parameters\n- `json_value`: The JSON structure that the HTTP request body must match. This parameter accepts any type that can be converted into a `serde_json::Value`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\nuse serde_json::json;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the request body to match a specific JSON structure\nlet mock = server.mock(|when, then| {\n    when.json_body(json!({\n        \"title\": \"The Great Gatsby\",\n        \"author\": \"F. Scott Fitzgerald\"\n    }));\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Make a request with a JSON body that matches the expected structure\nClient::new()\n    .post(&format!(\"http://{}/test\", server.address()))\n    .header(\"Content-Type\", \"application/json\") // It's important to set the Content-Type header manually\n    .body(r#\"{\"title\":\"The Great Gatsby\",\"author\":\"F. Scott Fitzgerald\"}\"#)\n    .send()\n    .unwrap();\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When’ instance to allow method chaining for additional configuration.\n",
    "json_body_excludes": "Sets the expected partial JSON body to ensure that specific content is not present within a larger JSON structure.\n\n**Attention:** The partial JSON string must be a valid JSON string and should represent a substructure\nof the full JSON object. It can omit irrelevant attributes but must maintain any necessary object hierarchy.\n\n**Note:** This method does not automatically set the `Content-Type` header to `application/json`.\nYou must explicitly set this header in your requests.\n\n# Parameters\n- `partial_body`: The partial JSON content to check for exclusion. This must be a valid JSON string.\n\n# Example\nSuppose your application sends the following JSON request body:\n```json\n{\n    \"parent_attribute\": \"Some parent data goes here\",\n    \"child\": {\n        \"target_attribute\": \"Example\",\n        \"other_attribute\": \"Another value\"\n    }\n}\n```\nTo verify the absence of `target_attribute` with the value `Example`:\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\nlet server = MockServer::start();\n\nlet mock = server.mock(|when, then| {\n    when.json_body_excludes(r#\"\n        {\n            \"child\": {\n                \"target_attribute\": \"Example\"\n            }\n        }\n    \"#);\n    then.status(200);\n});\n\n// Send a POST request with a JSON body\nlet response = Client::new()\n    .post(&format!(\"http://{}/some/path\", server.address()))\n    .header(\"content-type\", \"application/json\")\n    .body(r#\"\n        {\n            \"parent_attribute\": \"Some parent data goes here\",\n            \"child\": {\n                \"other_attribute\": \"Another value\"\n            }\n        }\n    \"#)\n    .send()\n    .unwrap();\n\n// Assert the mock was called and the response status is as expected\nmock.assert();\nassert_eq!(response.status(), 200);\n```\nIt's important that the partial JSON contains the full object hierarchy necessary to reach the target attribute.\nIrrelevant attributes such as `parent_attribute` and `child.other_attribute` in the example can be omitted.\n",
    "json_body_includes": "Sets the expected partial JSON body to check for specific content within a larger JSON structure.\n\n**Attention:** The partial JSON string must be a valid JSON string and should represent a substructure\nof the full JSON object. It can omit irrelevant attributes but must maintain any necessary object hierarchy.\n\n**Note:** This method does not automatically set the `Content-Type` header to `application/json`.\nYou must explicitly set this header in your requests.\n\n# Parameters\n- `partial_body`: The partial JSON content to check for. This must be a valid JSON string.\n\n# Example\nSuppose your application sends the following JSON request body:\n```json\n{\n    \"parent_attribute\": \"Some parent data goes here\",\n    \"child\": {\n        \"target_attribute\": \"Example\",\n        \"other_attribute\": \"Another value\"\n    }\n}\n```\nTo verify the presence of `target_attribute` with the value `Example` without needing the entire JSON object:\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\nlet server = MockServer::start();\n\nlet mock = server.mock(|when, then| {\n    when.json_body_includes(r#\"\n        {\n            \"child\": {\n                \"target_attribute\": \"Example\"\n            }\n        }\n    \"#);\n    then.status(200);\n});\n\n// Send a POST request with a JSON body\nlet response = Client::new()\n    .post(&format!(\"http://{}/some/path\", server.address()))\n    .header(\"content-type\", \"application/json\")\n    .body(r#\"\n        {\n            \"parent_attribute\": \"Some parent data goes here\",\n            \"child\": {\n                \"target_attribute\": \"Example\",\n                \"other_attribute\": \"Another value\"\n            }\n        }\n    \"#)\n    .send()\n    .unwrap();\n\n// Assert the mock was called and the response status is as expected\nmock.assert();\nassert_eq!(response.status(), 200);\n```\nIt's important that the partial JSON contains the full object hierarchy necessary to reach the target attribute.\nIrrelevant attributes such as `parent_attribute` and `child.other_attribute` can be omitted.\n",
    "json_body_obj": "Sets the expected JSON body using a serializable serde object.\nThis function automatically serializes the given object into a JSON string using serde.\n\n**Note**: This method does not automatically verify the `Content-Type` header.\nIf specific content type verification is required (e.g., `application/json`),\nyou must add this expectation manually.\n\n# Parameters\n- `body`: The HTTP body object to be serialized to JSON. This object should implement both `serde::Serialize` and `serde::Deserialize`.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\nuse serde_json::json;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct TestUser {\n    name: String,\n}\n\n// Initialize logging (optional, for debugging purposes)\nlet _ = env_logger::try_init();\n\n// Start the mock server\nlet server = MockServer::start();\n\n// Set up a mock endpoint\nlet m = server.mock(|when, then| {\n    when.path(\"/user\")\n        .header(\"content-type\", \"application/json\")\n        .json_body_obj(&TestUser { name: String::from(\"Fred\") });\n    then.status(200);\n});\n\n// Send a POST request with a JSON body\nlet response = Client::new()\n    .post(&format!(\"http://{}/user\", server.address()))\n    .header(\"content-type\", \"application/json\")\n    .body(json!(&TestUser { name: \"Fred\".to_string() }).to_string())\n    .send()\n    .unwrap();\n\n// Assert the mock was called and the response status is as expected\nm.assert();\nassert_eq!(response.status(), 200);\n```\n\nThis method is particularly useful when you need to test server responses to structured JSON data. It helps\nensure that the JSON serialization and deserialization processes are correctly implemented in your API handling logic.\n",
    "matches": "Adds a custom matcher for expected HTTP requests. If this function returns true, the request\nis considered a match, and the mock server will respond to the request\n(given all other criteria are also met).\n\nYou can use this function to create custom expectations for your mock server based on any aspect\nof the `HttpMockRequest` object.\n\n# Parameters\n- `matcher`: A function that takes a reference to an `HttpMockRequest` and returns a boolean indicating whether the request matches.\n\n## Example\n```rust\nuse httpmock::prelude::*;\n\n// Arrange\nlet server = MockServer::start();\n\nlet m = server.mock(|when, then| {\n   when.matches(|req: &HttpMockRequest| {\n        req.uri().path().contains(\"es\")\n   });\n   then.status(200);\n});\n\n// Act: Send the HTTP request\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Assert\nm.assert();\nassert_eq!(response.status(), 200);\n```\n\n# Returns\n`When`: Returns the modified `When` object with the new custom matcher added to the expectations.\n",
    "method": "Sets the expected HTTP method for which the mock server should respond.\n\nThis method ensures that the mock server only matches requests that use the specified HTTP method,\nsuch as `GET`, `POST`, or any other valid method. This allows testing behavior that's specific\nto different types of HTTP requests.\n\n**Note**: Method matching is case-insensitive.\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches only `GET` requests\nlet mock = server.mock(|when, then| {\n    when.method(GET);    // Match only `GET` HTTP method\n    then.status(200);    // Respond with status code 200 for all matched requests\n});\n\n// Make a GET request to the server's URL to trigger the mock\nlet response = reqwest::blocking::get(server.url(\"/\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `method`: An HTTP method as either a `Method` enum or a `String` value, specifying the expected method type for matching.\n\n# Returns\nThe updated `When` instance to allow for method chaining.\n\n",
    "method_not": "Excludes the specified HTTP method from the requests the mock server will respond to.\n\nThis method ensures that the mock server does not respond to requests using the given HTTP method,\nlike `GET`, `POST`, etc. This allows testing scenarios where a particular method should not\ntrigger a response, and thus testing behaviors like method-based security.\n\n**Note**: Method matching is case-insensitive.\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any request except those using the `POST` method\nlet mock = server.mock(|when, then| {\n    when.method_not(POST);  // Exclude the `POST` HTTP method from matching\n    then.status(200);       // Respond with status code 200 for all other matched requests\n});\n\n// Make a GET request to the server's URL, which will trigger the mock\nlet response = reqwest::blocking::get(server.url(\"/\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `method`: An HTTP method as either a `Method` enum or a `String` value, specifying the method type to exclude from matching.\n\n# Returns\nThe updated `When` instance to allow for method chaining.\n\n",
    "path": "Specifies the expected URL path that incoming requests must match for the mock server to respond.\nThis is useful for targeting specific endpoints, such as API routes, to ensure only relevant requests trigger the mock response.\n\n# Parameters\n- `path`: A string or other value convertible to `String` that represents the expected URL path.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches requests to `/test`\nlet mock = server.mock(|when, then| {\n    when.path(\"/test\");\n    then.status(200);  // Respond with a 200 status code\n});\n\n// Make a request to the mock server using the specified path\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance, allowing method chaining for additional configuration.\n\n",
    "path_excludes": "Specifies a substring that the URL path must *not* contain for the mock server to respond.\nThis constraint is useful for excluding requests to paths containing particular segments or patterns.\n\n# Parameters\n- `substring`: A string or other value convertible to `String` representing the substring that should not appear in the URL path.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any path not containing the substring \"xyz\"\nlet mock = server.mock(|when, then| {\n    when.path_excludes(\"xyz\");\n    then.status(200);  // Respond with status 200 for paths excluding \"xyz\"\n});\n\n// Make a request to a path that does not contain \"xyz\"\nlet response = reqwest::blocking::get(server.url(\"/testpath\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure the mock server returned the expected response\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to enable method chaining for additional configuration.\n\n",
    "path_includes": "Specifies a substring that the URL path must contain for the mock server to respond.\nThis constraint is useful for matching URLs based on partial segments, especially when exact path matching isn't required.\n\n# Parameters\n- `substring`: A string or any value convertible to `String` representing the substring that must be present in the URL path.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any path containing the substring \"es\"\nlet mock = server.mock(|when, then| {\n    when.path_includes(\"es\");\n    then.status(200);  // Respond with a 200 status code for matched requests\n});\n\n// Make a request to a path containing \"es\" to trigger the mock response\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for further configuration.\n\n",
    "path_matches": "Specifies a regular expression that the URL path must match for the mock server to respond.\nThis method allows flexible matching using regex patterns, making it useful for various matching scenarios.\n\n# Parameters\n- `regex`: An expression that implements `Into<Regex>`, representing the regex pattern to match against the URL path.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches paths ending with the suffix \"le\"\nlet mock = server.mock(|when, then| {\n    when.path_matches(r\"le$\");\n    then.status(200);  // Respond with a 200 status code for paths matching the pattern\n});\n\n// Make a request to a path ending with \"le\"\nlet response = reqwest::blocking::get(server.url(\"/example\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock server returned the expected response\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n# Errors\nThis function will panic if the provided regex pattern is invalid.\n\n",
    "path_not": "Specifies the URL path that incoming requests must *not* match for the mock server to respond.\nThis is helpful when you need to exclude specific endpoints while allowing others through.\n\nTo add multiple excluded paths, invoke this function multiple times.\n\n# Parameters\n- `path`: A string or other value convertible to `String` that represents the URL path to exclude.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that will not match requests to `/exclude`\nlet mock = server.mock(|when, then| {\n    when.path_not(\"/exclude\");\n    then.status(200);  // Respond with status 200 for all other paths\n});\n\n// Make a request to a path that does not match the exclusion\nlet response = reqwest::blocking::get(server.url(\"/include\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance, allowing method chaining for further configuration.\n\n",
    "path_prefix": "Specifies a prefix that the URL path must start with for the mock server to respond.\nThis is useful when only the initial segments of a path need to be validated, such as checking specific API routes.\n\n# Parameters\n- `prefix`: A string or other value convertible to `String` representing the prefix that the URL path should start with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any path starting with the prefix \"/api\"\nlet mock = server.mock(|when, then| {\n    when.path_prefix(\"/api\");\n    then.status(200);  // Respond with a 200 status code for matched requests\n});\n\n// Make a request to a path starting with \"/api\"\nlet response = reqwest::blocking::get(server.url(\"/api/v1/resource\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for further configuration.\n\n",
    "path_prefix_not": "Specifies a prefix that the URL path must not start with for the mock server to respond.\nThis constraint is useful for excluding paths that begin with particular segments or patterns.\n\n# Parameters\n- `prefix`: A string or other value convertible to `String` representing the prefix that the URL path should not start with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any path not starting with the prefix \"/admin\"\nlet mock = server.mock(|when, then| {\n    when.path_prefix_not(\"/admin\");\n    then.status(200);  // Respond with status 200 for paths excluding \"/admin\"\n});\n\n// Make a request to a path that does not start with \"/admin\"\nlet response = reqwest::blocking::get(server.url(\"/public/home\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock server returned the expected response\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "path_suffix": "Specifies a suffix that the URL path must end with for the mock server to respond.\nThis is useful when the final segments of a path need to be validated, such as file extensions or specific patterns.\n\n# Parameters\n- `suffix`: A string or other value convertible to `String` representing the suffix that the URL path should end with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any path ending with the suffix \".html\"\nlet mock = server.mock(|when, then| {\n    when.path_suffix(\".html\");\n    then.status(200);  // Respond with a 200 status code for matched requests\n});\n\n// Make a request to a path ending with \".html\"\nlet response = reqwest::blocking::get(server.url(\"/about/index.html\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for further configuration.\n\n",
    "path_suffix_not": "Specifies a suffix that the URL path must not end with for the mock server to respond.\nThis constraint is useful for excluding paths with specific file extensions or patterns.\n\n# Parameters\n- `suffix`: A string or other value convertible to `String` representing the suffix that the URL path should not end with.\n\n# Example\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that matches any path not ending with the suffix \".json\"\nlet mock = server.mock(|when, then| {\n    when.path_suffix_not(\".json\");\n    then.status(200);  // Respond with a 200 status code for paths excluding \".json\"\n});\n\n// Make a request to a path that does not end with \".json\"\nlet response = reqwest::blocking::get(server.url(\"/about/index.html\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for further configuration.\n\n",
    "port": "Specifies the expected port number for incoming requests to match.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\n# Parameters\n- `port`: A value convertible to `u16`, representing the expected port number.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Configure a mock to respond to requests made to `github.com`\n// with a specific port\nserver.mock(|when, then| {\n    when.port(80);  // Specify the expected port\n    then.body(\"This is a mock response\");\n});\n\n// Set up an HTTP client to use the mock server as a proxy\nlet client = Client::builder()\n    // Proxy all requests to the mock server\n    .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n    .build()\n    .unwrap();\n\n// Send a GET request to `github.com` on port 80.\n// The request will be sent to our mock server due to the HTTP client proxy settings.\nlet response = client.get(\"http://github.com:80\").send().unwrap();\n\n// Validate that the mock server returned the expected response\nassert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n\n# Errors\n- This function will panic if the port number cannot be converted to a valid `u16` value.\n\n# Returns\nThe updated `When` instance to allow method chaining.\n\n",
    "port_not": "Specifies the port number that incoming requests must *not* match.\n\nThis constraint is especially useful when working with proxy or forwarding rules, but it\ncan also be used to serve mocks (e.g., when using a mock server as a proxy).\n\nTo add multiple excluded ports, invoke this function multiple times.\n\n# Parameters\n- `port`: A value convertible to `u16`, representing the port number to be excluded.\n\n# Example\n```rust\nuse httpmock::prelude::*;\nuse reqwest::blocking::Client;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Configure a mock to respond to requests not using port 81\nserver.mock(|when, then| {\n    when.port_not(81);  // Exclude requests on port 81\n    then.body(\"This is a mock response\");\n});\n\n// Set up an HTTP client to use the mock server as a proxy\nlet client = Client::builder()\n    .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n    .build()\n    .unwrap();\n\n// Make a request to `github.com` on port 80, which will trigger\n// the mock response\nlet response = client.get(\"http://github.com:80\").send().unwrap();\n\n// Validate that the mock server returned the expected response\nassert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n\n# Errors\n- This function will panic if the port number cannot be converted to a valid `u16` value.\n\n# Returns\nThe updated `When` instance to enable method chaining.\n\n",
    "query_param": "Specifies a required query parameter for the request.\nThis function ensures that the specified query parameter (key-value pair) must be included\nin the request URL for the mock server to respond.\n\n**Note**: The request query keys and values are implicitly *allowed but not required* to be URL-encoded.\nHowever, the value passed to this method should always be in plain text (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to match against.\n- `value`: The expected value of the query parameter.\n\n# Example\n```rust\n// Arrange\nuse reqwest::blocking::get;\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query` to have the value \"This is cool\"\nlet m = server.mock(|when, then| {\n    when.query_param(\"query\", \"This is cool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that includes the specified query parameter and value\nget(&server.url(\"/search?query=This+is+cool\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "query_param_count": "Specifies that the count of query parameters with keys and values matching specific regular\nexpression patterns must equal a specified number for the request to match.\nThis function ensures that the number of query parameters whose keys and values match the\ngiven regex patterns is equal to the specified count in the request URL for the mock\nserver to respond.\n\n# Parameters\n- `key_regex`: A regular expression pattern for the query parameter's key to match against.\n- `value_regex`: A regular expression pattern for the query parameter's value to match against.\n- `expected_count`: The expected number of query parameters whose keys and values match the regex patterns.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects exactly two query parameters with keys matching the regex \"user.*\"\n// and values matching the regex \"admin.*\"\nlet m = server.mock(|when, then| {\n    when.query_param_count(r\"user.*\", r\"admin.*\", 2);\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that matches the conditions\nreqwest::blocking::get(&server.url(\"/search?user1=admin1&user2=admin2\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_excludes": "Specifies that a query parameter's value (**not** the key) must not contain a specific substring for the request to match.\n\nThis function ensures that the specified query parameter (key) does exist in the request URL, and\nit does not have a value containing the given substring for the mock server to respond.\n\n**Note**: The request query key-value pairs are implicitly *allowed but not required* to be URL-encoded.\nHowever, provide the substring in plain text here (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to match against.\n- `substring`: The substring that must not appear within the value of the query parameter.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query`\n// to have a value that does not contain \"uncool\"\nlet m = server.mock(|when, then| {\n    when.query_param_excludes(\"query\", \"uncool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that includes a value not containing the substring \"uncool\"\nreqwest::blocking::get(&server.url(\"/search?query=Something+cool\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_exists": "Specifies that a query parameter must be present in an HTTP request.\nThis function ensures that the specified query parameter key exists in the request URL\nfor the mock server to respond, regardless of the parameter's value.\n\n**Note**: The query key in the request is implicitly *allowed but not required* to be URL-encoded.\nHowever, provide the key in plain text here (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter that must exist in the request.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query` to exist, regardless of its value\nlet m = server.mock(|when, then| {\n    when.query_param_exists(\"query\");\n    then.status(200);  // Respond with a 200 status code if the parameter exists\n});\n\n// Act: Make a request with the specified query parameter\nreqwest::blocking::get(&server.url(\"/search?query=restaurants+near+me\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_includes": "Specifies that a query parameter's value (**not** the key) must contain a specific substring for the request to match.\nThis function ensures that the specified query parameter (key) does exist in the request URL, and\nit does have a value containing the given substring for the mock server to respond.\n\n**Note**: The request query key-value pairs are implicitly *allowed but not required* to be URL-encoded.\nHowever, provide the substring in plain text (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to match against.\n- `substring`: The substring that must appear within the value of the query parameter.\n\n# Example\n```rust\n// Arrange\nuse reqwest::blocking::get;\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query`\n// to have a value containing \"cool\"\nlet m = server.mock(|when, then| {\n    when.query_param_includes(\"query\", \"cool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that includes a value containing the substring \"cool\"\nget(server.url(\"/search?query=Something+cool\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_matches": "Specifies that a query parameter must match a specific regular expression pattern for the key and another pattern for the value.\nThis function ensures that the specified query parameter key-value pair matches the given patterns\nin the request URL for the mock server to respond.\n\n# Parameters\n- `key_regex`: A regular expression pattern for the query parameter's key to match against.\n- `value_regex`: A regular expression pattern for the query parameter's value to match against.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter key to match the regex \"user.*\"\n// and the value to match the regex \"admin.*\"\nlet m = server.mock(|when, then| {\n    when.query_param_matches(r\"user.*\", r\"admin.*\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that matches the regex patterns for both key and value\nreqwest::blocking::get(&server.url(\"/search?user=admin_user\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_missing": "Specifies that a query parameter must *not* be present in an HTTP request.\nThis function ensures that the specified query parameter key is absent in the request URL\nfor the mock server to respond, regardless of the parameter's value.\n\n**Note**: The request query key is implicitly *allowed but not required* to be URL-encoded.\nHowever, provide the key in plain text (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter that should be missing from the request.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query` to be missing\nlet m = server.mock(|when, then| {\n    when.query_param_missing(\"query\");\n    then.status(200);  // Respond with a 200 status code if the parameter is absent\n});\n\n// Act: Make a request without the specified query parameter\nreqwest::blocking::get(&server.url(\"/search\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_not": "This function ensures that the specified query parameter (key) does exist in the request URL,\nand its value is not equal to the specified value.\n\n**Note**: Query keys and values are implicitly *allowed but not required* to be URL-encoded\nin the HTTP request. However, values passed to this method should always be in plain text\n(i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to ensure is not present.\n- `value`: The value of the query parameter to ensure is not present.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query` to NOT have the value \"This is cool\"\nlet m = server.mock(|when, then| {\n    when.query_param_not(\"query\", \"This is cool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that does not include the specified query parameter and value\nlet response = reqwest::blocking::get(&server.url(\"/search?query=awesome\")).unwrap();\n\n// Assert: Verify that the mock was called\nassert_eq!(response.status(), 200);\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n",
    "query_param_prefix": "Specifies that a query parameter's value (**not** the key) must start with a specific prefix for the request to match.\nThis function ensures that the specified query parameter (key) has a value starting with the given prefix\nin the request URL for the mock server to respond.\n\n**Note**: The request query key-value pairs are implicitly *allowed but not required* to be URL-encoded.\nProvide the prefix in plain text here (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to match against.\n- `prefix`: The prefix that the query parameter value should start with.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query`\n// to have a value starting with \"cool\"\nlet m = server.mock(|when, then| {\n    when.query_param_prefix(\"query\", \"cool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that includes a value starting with the prefix \"cool\"\nreqwest::blocking::get(&server.url(\"/search?query=cool+stuff\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_prefix_not": "Specifies that a query parameter's value (**not** the key) must not start with a specific prefix for the request to match.\nThis function ensures that the specified query parameter (key) has a value not starting with the given prefix\nin the request URL for the mock server to respond.\n\n**Note**: The request query key-value pairs are implicitly *allowed but not required* to be URL-encoded.\nProvide the prefix in plain text here (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to match against.\n- `prefix`: The prefix that the query parameter value should not start with.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query`\n// to have a value not starting with \"cool\"\nlet m = server.mock(|when, then| {\n    when.query_param_prefix_not(\"query\", \"cool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that does not start with the prefix \"cool\"\nreqwest::blocking::get(&server.url(\"/search?query=warm_stuff\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_suffix": "Specifies that a query parameter's value (**not** the key) must end with a specific suffix for the request to match.\nThis function ensures that the specified query parameter (key) has a value ending with the given suffix\nin the request URL for the mock server to respond.\n\n**Note**: The request query key-value pairs are implicitly *allowed but not required* to be URL-encoded.\nProvide the suffix in plain text here (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to match against.\n- `suffix`: The suffix that the query parameter value should end with.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query`\n// to have a value ending with \"cool\"\nlet m = server.mock(|when, then| {\n    when.query_param_suffix(\"query\", \"cool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that includes a value ending with the suffix \"cool\"\nreqwest::blocking::get(&server.url(\"/search?query=really_cool\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "query_param_suffix_not": "Specifies that a query parameter's value (**not** the key) must not end with a specific suffix for the request to match.\nThis function ensures that the specified query parameter (key) has a value not ending with the given suffix\nin the request URL for the mock server to respond.\n\n**Note**: The request query key-value pairs are implicitly *allowed but not required* to be URL-encoded.\nProvide the suffix in plain text here (i.e., not encoded).\n\n# Parameters\n- `name`: The name of the query parameter to match against.\n- `suffix`: The suffix that the query parameter value should not end with.\n\n# Example\n```rust\n// Arrange\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that expects the query parameter `query`\n// to have a value not ending with \"cool\"\nlet m = server.mock(|when, then| {\n    when.query_param_suffix_not(\"query\", \"cool\");\n    then.status(200);  // Respond with a 200 status code if the condition is met\n});\n\n// Act: Make a request that doesn't end with the suffix \"cool\"\nreqwest::blocking::get(&server.url(\"/search?query=uncool_stuff\")).unwrap();\n\n// Assert: Verify that the mock was called at least once\nm.assert();\n```\n\n# Returns\nThe updated `When` instance to allow method chaining for additional configuration.\n\n",
    "scheme": "Specifies the scheme (e.g., \"http\" or \"https\") that requests must match for the mock server to respond.\n\nThis method sets the scheme to filter requests and ensures that the mock server only matches\nrequests with the specified scheme. This allows for more precise testing in environments where\nmultiple protocols are used.\n\n**Note**: Scheme matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// If the \"https\" feature is enabled, `server.url` below will generate a URL using\n// the \"https\" scheme (e.g., https://localhost:34567/test). Otherwise, it will\n// use \"http\" (e.g., http://localhost:34567/test).\nlet expected_scheme = if cfg!(feature = \"https\") { \"https\" } else { \"http\" };\n\n// Create a mock that only matches requests with the \"http\" scheme\nlet mock = server.mock(|when, then| {\n    when.scheme(expected_scheme);  // Restrict to the \"http\" scheme\n    then.status(200);              // Respond with status code 200 for all matched requests\n});\n\n// Make an \"http\" request to the server's URL to trigger the mock\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Verify that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `scheme`: A string specifying the scheme that requests should match. Common values include \"http\" and \"https\".\n\n# Returns\nThe modified `When` instance to allow for method chaining.\n\n",
    "scheme_not": "Specifies a scheme (e.g., \"https\") that requests must not match for the mock server to respond.\n\nThis method allows you to exclude specific schemes from matching, ensuring that the mock server\nwon't respond to requests using those protocols. This is useful when you want to mock server\nbehavior based on protocol security requirements or other criteria.\n\n**Note**: Scheme matching is case-insensitive, conforming to\n[RFC 3986, Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2).\n\n# Example\n\n```rust\nuse httpmock::prelude::*;\n\n// Start a new mock server\nlet server = MockServer::start();\n\n// Create a mock that will only match requests that do not use the \"https\" scheme\nlet mock = server.mock(|when, then| {\n    when.scheme_not(\"ftp\");  // Exclude the \"ftp\" scheme from matching\n    then.status(200);        // Respond with status code 200 for all matched requests\n});\n\n// Make a request to the server's URL with the \"http\" scheme to trigger the mock\nlet response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n// Ensure the request was successful\nassert_eq!(response.status(), 200);\n\n// Ensure that the mock was called at least once\nmock.assert();\n```\n\n# Parameters\n- `scheme`: A string specifying the scheme that requests should not match. Common values include \"http\" and \"https\".\n\n# Returns\nThe modified `When` instance to allow for method chaining.\n\n"
  }
}