{
  "record-proxy-website": "#[cfg(all(feature = \"proxy\", feature = \"https\", feature = \"record\"))]\n#[test]\nfn record_with_proxy_example_test() {\n    use httpmock::RecordingRuleBuilder;\n\n    // Start a mock server to act as a proxy for the HTTP client\n    let recording_proxy_server = MockServer::start();\n\n    // Configure the mock server to proxy all incoming requests\n    recording_proxy_server.proxy(|rule| {\n        rule.filter(|when| {\n            when.any_request(); // Intercept all requests\n        });\n    });\n\n    // Set up recording on the mock server to capture all proxied\n    // requests and responses\n    let recording = recording_proxy_server.record(|rule: RecordingRuleBuilder| {\n        rule.filter(|when| {\n            when.any_request(); // Record all requests\n        });\n    });\n\n    // Create an HTTP client configured to route requests\n    // through the mock proxy server\n    let github_client = Client::builder()\n        // Set the proxy URL to the mock server's URL\n        .proxy(reqwest::Proxy::all(recording_proxy_server.base_url()).unwrap())\n        .build()\n        .unwrap();\n\n    // Send a GET request using the client, which will be proxied by the mock server\n    let response = github_client.get(\"https://httpmock.rs\").send().unwrap();\n\n    // Since the request was forwarded, we should see a GitHub API response.\n    assert_eq!(response.status().as_u16(), 200);\n    assert!(response\n        .text()\n        .unwrap()\n        .contains(\"Simple yet powerful HTTP mocking library for Rust\"));\n\n    // Save the recording to\n    // \"target/httpmock/recordings/website-via-proxy_<timestamp>.yaml\".\n    recording\n        .save(\"website-via-proxy\")\n        .expect(\"could not save the recording\");\n}",
  "playback-forwarding-website": "#[cfg(all(feature = \"record\"))]\n#[test]\nfn playback_github_api() {\n    // Start a mock server for the test\n    let server = MockServer::start();\n\n    // Configure the mock server to forward requests to the target\n    // host (GitHub API) instead of responding with a mock. The 'rule'\n    // parameter allows you to define conditions under which forwarding\n    // should occur.\n    server.forward_to(\"https://httpmock.rs\", |rule| {\n        rule.filter(|when| {\n            when.any_request(); // Forward all requests.\n        });\n    });\n\n    // Set up recording to capture all forwarded requests and responses\n    let recording = server.record(|rule| {\n        rule.filter(|when| {\n            when.any_request(); // Record all requests and responses.\n        });\n    });\n\n    // Send an HTTP request to the mock server, which will be forwarded\n    // to the GitHub API\n    let client = Client::new();\n    let response = client.get(server.base_url()).send().unwrap();\n\n    // Assert that the response from the forwarded request is as expected\n    assert_eq!(response.status().as_u16(), 200);\n    assert!(response\n        .text()\n        .unwrap()\n        .contains(\"Simple yet powerful HTTP mocking library for Rust\"));\n\n    // Save the recorded interactions to a file\n    let target_path = recording\n        .save(\"github-torvalds-scenario\")\n        .expect(\"Failed to save the recording to disk\");\n\n    // Start a new mock server instance for playback\n    let playback_server = MockServer::start();\n\n    // Load the recorded interactions into the new mock server\n\n    playback_server.playback(target_path);\n\n    // Send a request to the playback server and verify the response\n    // matches the recorded data\n    let response = client.get(playback_server.base_url()).send().unwrap();\n    assert_eq!(response.status().as_u16(), 200);\n    assert!(response\n        .text()\n        .unwrap()\n        .contains(\"Simple yet powerful HTTP mocking library for Rust\"));\n}",
  "forwarding": "#[cfg(feature = \"proxy\")]\n#[test]\nfn forwarding_test() {\n    // We will create this mock server to simulate a real service (e.g., GitHub, AWS, etc.).\n    let target_server = MockServer::start();\n    target_server.mock(|when, then| {\n        when.any_request();\n        then.status(200).body(\"Hi from fake GitHub!\");\n    });\n\n    // Let's create our mock server for the test\n    let server = MockServer::start();\n\n    // We configure our server to forward the request to the target host instead of\n    // answering with a mocked response. The 'when' variable lets you configure\n    // rules under which forwarding should take place.\n    server.forward_to(target_server.base_url(), |rule| {\n        rule.filter(|when| {\n            when.any_request(); // We want all requests to be forwarded.\n        });\n    });\n\n    // Now let's send an HTTP request to the mock server. The request will be forwarded\n    // to the target host, as we configured before.\n    let client = Client::new();\n\n    // Since the request was forwarded, we should see the target host's response.\n    let response = client.get(server.url(\"/get\")).send().unwrap();\n    assert_eq!(response.status().as_u16(), 200);\n    assert_eq!(response.text().unwrap(), \"Hi from fake GitHub!\");\n}",
  "record-forwarding-website": "#[cfg(all(feature = \"record\"))]\n#[test]\nfn record_with_forwarding_example_test() {\n    // Let's create our mock server for the test\n    let server = MockServer::start();\n\n    // We configure our server to forward the request to the target\n    // host instead of answering with a mocked response. The 'when'\n    // variable lets you configure rules under which forwarding\n    // should take place.\n    server.forward_to(\"https://httpmock.rs\", |rule| {\n        rule.filter(|when| {\n            when.any_request(); // Ensure all requests are forwarded.\n        });\n    });\n\n    let recording = server.record(|rule| {\n        rule.filter(|when| {\n            when.any_request(); // Ensure all requests are recorded.\n        });\n    });\n\n    // Now let's send an HTTP request to the mock server. The request\n    // will be forwarded to the GitHub API, as we configured before.\n    let client = Client::new();\n\n    let response = client.get(server.base_url()).send().unwrap();\n\n    // Since the request was forwarded, we should see a GitHub API response.\n    assert_eq!(response.status().as_u16(), 200);\n    assert!(response\n        .text()\n        .unwrap()\n        .contains(\"Simple yet powerful HTTP mocking library for Rust\"));\n\n    // Save the recording to\n    // \"target/httpmock/recordings/website-via-forwarding_<timestamp>.yaml\".\n    recording\n        .save(\"website-via-forwarding\")\n        .expect(\"cannot store recording on disk\");\n}",
  "forwarding-github": "#[cfg(feature = \"proxy\")]\n#[test]\nfn forward_to_website() {\n    // Let's create our mock server for the test\n    let server = MockServer::start();\n\n    // We configure our server to forward the request to the target\n    // host instead of answering with a mocked response. The 'when'\n    // variable lets you configure rules under which forwarding\n    // should take place.\n    server.forward_to(\"https://httpmock.rs\", |rule| {\n        rule.filter(|when| {\n            when.any_request(); // Ensure all requests are forwarded.\n        });\n    });\n\n    // Now let's send an HTTP request to the mock server. The request\n    // will be forwarded to the GitHub API, as we configured before.\n    let client = Client::new();\n\n    let response = client.get(server.base_url()).send().unwrap();\n\n    // Since the request was forwarded, we should see a GitHub API response.\n    assert_eq!(response.status().as_u16(), 200);\n    assert!(response\n        .text()\n        .unwrap()\n        .contains(\"Simple yet powerful HTTP mocking library for Rust\"));\n}"
}