{
  "then": {
    "and": "```rust\n use std::time::Duration;\n use http::{StatusCode, header::HeaderValue};\n use httpmock::{Then, MockServer};\n\n // Function that configures a response with JSON content and a delay\n fn ok_json_with_delay(then: Then) -> Then {\n     then.status(StatusCode::OK.as_u16())\n         .header(\"content-type\", \"application/json\")\n         .delay(Duration::from_secs_f32(0.5))\n }\n\n // Usage within a method chain\n let server = MockServer::start();\n let then = server.mock(|when, then| {\n     when.path(\"/example\");\n     then.header(\"general-vibe\", \"much better\")\n         .and(ok_json_with_delay);\n });\n\n // The `and` method keeps the setup intuitively readable as a continuous chain\n```\n",
    "body": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Initialize the mock server\n let server = MockServer::start();\n\n // Configure the mock\n let m = server.mock(|when, then| {\n     when.path(\"/hello\");\n     then.status(200)\n         .body(\"ohi!\");\n });\n\n // Send a request and verify the response\n let response = Client::new()\n     .get(server.url(\"/hello\"))\n     .send()\n     .unwrap();\n\n // Check that the mock was called as expected and the response body is as configured\n m.assert();\n assert_eq!(response.status(), 200);\n assert_eq!(response.text().unwrap(), \"ohi!\");\n```\n",
    "body_from_file": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Initialize the mock server\n let server = MockServer::start();\n\n // Configure the mock\n let m = server.mock(|when, then| {\n     when.path(\"/hello\");\n     then.status(200)\n         .body_from_file(\"tests/resources/simple_body.txt\");\n });\n\n // Send a request and verify the response\n let response = Client::new()\n     .get(server.url(\"/hello\"))\n     .send()\n     .unwrap();\n\n // Check that the mock was called as expected and the response body matches the file contents\n m.assert();\n assert_eq!(response.status(), 200);\n assert_eq!(response.text().unwrap(), \"ohi!\");\n```\n",
    "delay": "```rust\n use std::time::{SystemTime, Duration};\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let _ = env_logger::try_init();\n let start_time = SystemTime::now();\n let three_seconds = Duration::from_secs(3);\n let server = MockServer::start();\n\n // Configure the mock\n let mock = server.mock(|when, then| {\n     when.path(\"/delay\");\n     then.status(200)\n         .delay(three_seconds);\n });\n\n // Act\n let response = Client::new()\n     .get(server.url(\"/delay\"))\n     .send()\n     .unwrap();\n\n // Assert\n mock.assert();\n assert!(start_time.elapsed().unwrap() >= three_seconds);\n```\n",
    "header": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let _ = env_logger::try_init();\n let server = MockServer::start();\n\n // Configure the mock\n let m = server.mock(|when, then| {\n     when.path(\"/\");\n     then.status(200)\n         .header(\"Expires\", \"Wed, 21 Oct 2050 07:28:00 GMT\");\n });\n\n // Act\n let response = Client::new()\n     .get(server.url(\"/\"))\n     .send()\n     .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 200);\n assert_eq!(\n     response.headers().get(\"Expires\").unwrap().to_str().unwrap(),\n     \"Wed, 21 Oct 2050 07:28:00 GMT\"\n );\n```\n",
    "json_body": "```rust\n use httpmock::prelude::*;\n use serde_json::{Value, json};\n use reqwest::blocking::Client;\n\n // Arrange\n let _ = env_logger::try_init();\n let server = MockServer::start();\n\n // Configure the mock\n let m = server.mock(|when, then| {\n     when.path(\"/user\");\n     then.status(200)\n         .header(\"content-type\", \"application/json\")\n         .json_body(json!({ \"name\": \"Hans\" }));\n });\n\n // Act\n let response = Client::new()\n     .get(server.url(\"/user\"))\n     .send()\n     .unwrap();\n\n // Get the status code first\n let status = response.status();\n\n // Extract the text from the response\n let response_text = response.text().unwrap();\n\n // Deserialize the JSON response\n let user: Value =\n     serde_json::from_str(&response_text).expect(\"cannot deserialize JSON\");\n\n // Assert\n m.assert();\n assert_eq!(status, 200);\n assert_eq!(user[\"name\"], \"Hans\");\n```\n",
    "json_body_obj": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n use serde::{Serialize, Deserialize};\n\n #[derive(Serialize, Deserialize)]\n struct TestUser {\n     name: String,\n }\n\n // Arrange\n let _ = env_logger::try_init();\n let server = MockServer::start();\n\n // Configure the mock\n let m = server.mock(|when, then| {\n     when.path(\"/user\");\n     then.status(200)\n         .header(\"content-type\", \"application/json\")\n         .json_body_obj(&TestUser {\n             name: String::from(\"Hans\"),\n         });\n });\n\n // Act\n let response = Client::new()\n     .get(server.url(\"/user\"))\n     .send()\n     .unwrap();\n\n // Get the status code first\n let status = response.status();\n\n // Extract the text from the response\n let response_text = response.text().unwrap();\n\n // Deserialize the JSON response into a TestUser object\n let user: TestUser =\n     serde_json::from_str(&response_text).unwrap();\n\n // Assert\n m.assert();\n assert_eq!(status, 200);\n assert_eq!(user.name, \"Hans\");\n```\n",
    "status": "```rust\n use httpmock::prelude::*;\n\n // Initialize the mock server\n let server = MockServer::start();\n\n // Configure the mock\n let m = server.mock(|when, then| {\n     when.path(\"/hello\");\n     then.status(200);\n });\n\n // Send a request and verify the response\n let response = reqwest::blocking::get(server.url(\"/hello\")).unwrap();\n\n // Check that the mock was called as expected and the response status is as configured\n m.assert();\n assert_eq!(response.status(), 200);\n```\n"
  },
  "when": {
    "and": "```rust\n use httpmock::{prelude::*, When};\n use httpmock::Method::POST;\n\n // Function to apply a standard authorization and content type setup for JSON POST requests\n fn is_authorized_json_post_request(when: When) -> When {\n     when.method(POST)\n         .header(\"Authorization\", \"SOME API KEY\")\n         .header(\"Content-Type\", \"application/json\")\n }\n\n // Usage example demonstrating how to maintain fluent interface style with complex setups.\n // This approach keeps the chain of conditions clear and readable, enhancing test legibility\n let server = MockServer::start();\n let m = server.mock(|when, then| {\n     when.query_param(\"user_id\", \"12345\")\n         .and(is_authorized_json_post_request) // apply the function to include common setup\n         .json_body_includes(r#\"{\"key\": \"value\"}\"#); // additional specific condition\n     then.status(200);\n });\n```\n",
    "any_request": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Configure the mock server to respond to any request\n let mock = server.mock(|when, then| {\n     when.any_request();  // Explicitly specify that any request should match\n     then.status(200);    // Respond with status code 200 for all matched requests\n });\n\n // Make a request to the server's URL and ensure the mock is triggered\n let response = reqwest::blocking::get(server.url(\"/anyPath\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Assert that the mock was called at least once\n mock.assert();\n```\n",
    "body": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to be \"The Great Gatsby\"\n let mock = server.mock(|when, then| {\n     when.body(\"The Great Gatsby\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with the required body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"The Great Gatsby\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_excludes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to not contain the substring \"Gatsby\"\n let mock = server.mock(|when, then| {\n     when.body_excludes(\"Gatsby\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with a different body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"A Tale of Two Cities is a novel.\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_includes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to contain the substring \"Gatsby\"\n let mock = server.mock(|when, then| {\n     when.body_includes(\"Gatsby\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with the required substring in the body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"The Great Gatsby is a novel.\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_matches": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to match the regex pattern \"^The Great Gatsby.*\"\n let mock = server.mock(|when, then| {\n     when.body_matches(\"^The Great Gatsby.*\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with a body that matches the regex pattern\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"The Great Gatsby is a novel by F. Scott Fitzgerald.\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to not be \"The Great Gatsby\"\n let mock = server.mock(|when, then| {\n     when.body_not(\"The Great Gatsby\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with a different body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"A Tale of Two Cities\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_prefix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to begin with the substring \"The Great\"\n let mock = server.mock(|when, then| {\n     when.body_prefix(\"The Great\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with the required prefix in the body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"The Great Gatsby is a novel.\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_prefix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to not begin with the substring \"Error:\"\n let mock = server.mock(|when, then| {\n     when.body_prefix_not(\"Error:\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with a different body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"Success: Operation completed.\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_suffix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to end with the substring \"a novel.\"\n let mock = server.mock(|when, then| {\n     when.body_suffix(\"a novel.\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with the required suffix in the body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"The Great Gatsby is a novel.\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "body_suffix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to not end with the substring \"a novel.\"\n let mock = server.mock(|when, then| {\n     when.body_suffix_not(\"a novel.\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with a different body content\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .body(\"The Great Gatsby is a story.\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" with the value \"1234567890\"\n let mock = server.mock(|when, then| {\n     when.cookie(\"SESSIONID\", \"1234567890\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234567890; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_count": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie with a name matching the regex \"^SESSION\"\n // and a value matching the regex \"^[0-9]{10}$\" to appear exactly twice\n let mock = server.mock(|when, then| {\n     when.cookie_count(r\"^SESSION\", r\"^[0-9]{10}$\", 2);\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookies\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"SESSIONID=1234567890; TRACK=12345; SESSIONTOKEN=0987654321; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_excludes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" with a value not containing \"1234\"\n let mock = server.mock(|when, then| {\n     when.cookie_excludes(\"SESSIONID\", \"1234\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcdef; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_exists": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\"\n let mock = server.mock(|when, then| {\n     when.cookie_exists(\"SESSIONID\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234567890; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_includes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" with a value containing \"1234\"\n let mock = server.mock(|when, then| {\n     when.cookie_includes(\"SESSIONID\", \"1234\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=abc1234def; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_matches": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie with a name matching the regex \"^SESSION\"\n // and a value matching the regex \"^[0-9]{10}$\"\n let mock = server.mock(|when, then| {\n     when.cookie_matches(r\"^SESSION\", r\"^[0-9]{10}$\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234567890; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_missing": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" not to exist\n let mock = server.mock(|when, then| {\n     when.cookie_missing(\"SESSIONID\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that does not include the excluded cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" to not have the value \"1234567890\"\n let mock = server.mock(|when, then| {\n     when.cookie_not(\"SESSIONID\", \"1234567890\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=0987654321; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_prefix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" with a value starting with \"1234\"\n let mock = server.mock(|when, then| {\n     when.cookie_prefix(\"SESSIONID\", \"1234\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=1234abcdef; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_prefix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" with a value not starting with \"1234\"\n let mock = server.mock(|when, then| {\n     when.cookie_prefix_not(\"SESSIONID\", \"1234\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcd1234; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_suffix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" with a value ending with \"7890\"\n let mock = server.mock(|when, then| {\n     when.cookie_suffix(\"SESSIONID\", \"7890\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcdef7890; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "cookie_suffix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects a cookie named \"SESSIONID\" with a value not ending with \"7890\"\n let mock = server.mock(|when, then| {\n     when.cookie_suffix_not(\"SESSIONID\", \"7890\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required cookie\n  Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Cookie\", \"TRACK=12345; SESSIONID=abcdef1234; CONSENT=1\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "form_urlencoded_tuple": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple(\"name\", \"Peter Griffin\")\n        .form_urlencoded_tuple(\"town\", \"Quahog\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_count": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n use regex::Regex;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_count(\n            Regex::new(r\"^name$\").unwrap(),\n            Regex::new(r\".*Griffin$\").unwrap(),\n            2\n        );\n    then.status(202);\n });\n\n // Act\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&name=Lois%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_excludes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_excludes(\"name\", \"Griffin\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Lois%20Smith&city=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_exists": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_exists(\"name\")\n        .form_urlencoded_tuple_exists(\"town\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_includes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_includes(\"name\", \"Griffin\")\n        .form_urlencoded_tuple_includes(\"town\", \"Quahog\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_matches": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n use regex::Regex;\n\n // Arrange\n let server = MockServer::start();\n\n let key_regex = Regex::new(r\"^name$\").unwrap();\n let value_regex = Regex::new(r\"^Peter\\sGriffin$\").unwrap();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_matches(key_regex, value_regex);\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_missing": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_missing(\"name\")\n        .form_urlencoded_tuple_missing(\"town\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"city=Quahog&occupation=Cartoonist\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_not(\"name\", \"Peter Griffin\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Lois%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_prefix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_prefix(\"name\", \"Pete\")\n        .form_urlencoded_tuple_prefix(\"town\", \"Qua\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_prefix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_prefix_not(\"name\", \"Lois\")\n        .form_urlencoded_tuple_prefix_not(\"town\", \"Hog\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_suffix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_suffix(\"name\", \"Griffin\")\n        .form_urlencoded_tuple_suffix(\"town\", \"hog\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "form_urlencoded_tuple_suffix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.method(POST)\n        .path(\"/example\")\n        .header(\"content-type\", \"application/x-www-form-urlencoded\")\n        .form_urlencoded_tuple_suffix_not(\"name\", \"Smith\")\n        .form_urlencoded_tuple_suffix_not(\"town\", \"ville\");\n    then.status(202);\n });\n\n let response = Client::new()\n    .post(server.url(\"/example\"))\n    .header(\"content-type\", \"application/x-www-form-urlencoded\")\n    .body(\"name=Peter%20Griffin&town=Quahog\")\n    .send()\n    .unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 202);\n```\n",
    "header": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header with a specific value\n let mock = server.mock(|when, then| {\n     when.header(\"Authorization\", \"token 1234567890\");\n     then.status(200);  // Respond with a 200 status code if the header and value are present\n });\n\n // Make a request that includes the \"Authorization\" header with the specified value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_count": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects at least 2 headers whose keys match the regex \"^X-Custom-Header.*\"\n // and values match the regex \"value.*\"\n let mock = server.mock(|when, then| {\n     when.header_count(\"^X-Custom-Header.*\", \"value.*\", 2);\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request that includes the required headers\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"x-custom-header-1\", \"value1\")\n     .header(\"X-Custom-Header-2\", \"value2\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_excludes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header's value to not contain \"Bearer\"\n let mock = server.mock(|when, then| {\n     when.header_excludes(\"Authorization\", \"Bearer\");\n     then.status(200);  // Respond with a 200 status code if the header value does not contain the substring\n });\n\n // Make a request that includes the \"Authorization\" header without the forbidden substring in its value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_exists": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header to be present in the request\n let mock = server.mock(|when, then| {\n     when.header_exists(\"Authorization\");\n     then.status(200);  // Respond with a 200 status code if the header is present\n });\n\n // Make a request that includes the \"Authorization\" header\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_includes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header's value to contain \"token\"\n let mock = server.mock(|when, then| {\n     when.header_includes(\"Authorization\", \"token\");\n     then.status(200);  // Respond with a 200 status code if the header value contains the substring\n });\n\n // Make a request that includes the \"Authorization\" header with the specified substring in its value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_matches": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header's key to match the regex \"^Auth.*\"\n // and its value to match the regex \"token .*\"\n let mock = server.mock(|when, then| {\n     when.header_matches(\"^Auth.*\", \"token .*\");\n     then.status(200);  // Respond with a 200 status code if the header key and value match the patterns\n });\n\n // Make a request that includes the \"Authorization\" header with a value matching the regex\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_missing": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header to be absent in the request\n let mock = server.mock(|when, then| {\n     when.header_missing(\"Authorization\");\n     then.status(200);  // Respond with a 200 status code if the header is absent\n });\n\n // Make a request that does not include the \"Authorization\" header\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header with a specific value to be absent\n let mock = server.mock(|when, then| {\n     when.header_not(\"Authorization\", \"token 1234567890\");\n     then.status(200);  // Respond with a 200 status code if the header and value are absent\n });\n\n // Make a request that includes the \"Authorization\" header with a different value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token abcdefg\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_prefix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header's value to start with \"token\"\n let mock = server.mock(|when, then| {\n     when.header_prefix(\"Authorization\", \"token\");\n     then.status(200);  // Respond with a 200 status code if the header value starts with the prefix\n });\n\n // Make a request that includes the \"Authorization\" header with the specified prefix in its value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_prefix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header's value to not start with \"Bearer\"\n let mock = server.mock(|when, then| {\n     when.header_prefix_not(\"Authorization\", \"Bearer\");\n     then.status(200);  // Respond with a 200 status code if the header value does not start with the prefix\n });\n\n // Make a request that includes the \"Authorization\" header without the \"Bearer\" prefix in its value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_suffix": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header's value to end with \"7890\"\n let mock = server.mock(|when, then| {\n     when.header_suffix(\"Authorization\", \"7890\");\n     then.status(200);  // Respond with a 200 status code if the header value ends with the suffix\n });\n\n // Make a request that includes the \"Authorization\" header with the specified suffix in its value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "header_suffix_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the \"Authorization\" header's value to not end with \"abc\"\n let mock = server.mock(|when, then| {\n     when.header_suffix_not(\"Authorization\", \"abc\");\n     then.status(200);  // Respond with a 200 status code if the header value does not end with the suffix\n });\n\n // Make a request that includes the \"Authorization\" header without the \"abc\" suffix in its value\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Authorization\", \"token 1234567890\")\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "host": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n let server = MockServer::start();\n\n server.mock(|when, then| {\n     when.host(\"github.com\");\n     then.body(\"This is a mock response\");\n });\n\n let client = Client::builder()\n     .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n     .build()\n     .unwrap();\n\n let response = client.get(\"http://github.com\").send().unwrap();\n\n assert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n",
    "host_excludes": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that excludes any request where the host name contains \"www.google.com\"\n let mock = server.mock(|when, then| {\n     when.host_excludes(\"www.google.com\");  // Exclude hosts containing \"www.google.com\"\n     then.status(200);                      // Respond with status code 200 for other matched requests\n });\n\n // Make a request to a URL whose host name will be \"localhost\" and trigger the mock\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "host_includes": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any request where the host name contains \"localhost\"\n let mock = server.mock(|when, then| {\n     when.host_includes(\"0.0\");  // Only match hosts containing \"0.0\" (e.g., 127.0.0.1)\n     then.status(200);           // Respond with status code 200 for all matched requests\n });\n\n // Make a request to a URL whose host name is \"localhost\" to trigger the mock\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "host_matches": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches requests where the host name is exactly \"localhost\"\n let mock = server.mock(|when, then| {\n     when.host_matches(r\"^127.0.0.1$\");\n     then.status(200);\n });\n\n // Make a request with \"127.0.0.1\" as the host name to trigger the mock response.\n let response = reqwest::blocking::get(server.url(\"/\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "host_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n let server = MockServer::start();\n\n server.mock(|when, then| {\n     when.host(\"github.com\");\n     then.body(\"This is a mock response\");\n });\n\n let client = Client::builder()\n     .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n     .build()\n     .unwrap();\n\n let response = client.get(\"http://github.com\").send().unwrap();\n\n assert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n",
    "host_prefix": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any request where the host name starts with \"local\"\n let mock = server.mock(|when, then| {\n     when.host_prefix(\"127.0\");      // Only match hosts starting with \"127.0\"\n     then.status(200);               // Respond with status code 200 for all matched requests\n });\n\n // Make a request to the mock server with a host name of \"127.0.0.1\" to trigger the mock response.\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "host_prefix_not": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any request where the host name does not start with \"www.\"\n let mock = server.mock(|when, then| {\n     when.host_prefix_not(\"www.\");      // Exclude hosts starting with \"www\"\n     then.status(200);                  // Respond with status code 200 for all other requests\n });\n\n // Make a request with host name \"localhost\" that does not start with \"www\" and therefore\n // triggers the mock response.\n let response = reqwest::blocking::get(server.url(\"/example\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "host_suffix": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any request where the host name ends with \"host\" (e.g., \"localhost\").\n let mock = server.mock(|when, then| {\n     when.host_suffix(\"0.1\");    // Only match hosts ending with \"0.1\"\n     then.status(200);           // Respond with status code 200 for all matched requests\n });\n\n // Make a request to the mock server with a host name of \"127.0.0.1\" to trigger the mock response.\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "host_suffix_not": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any request where the host name does not end with \"host\".\n let mock = server.mock(|when, then| {\n     when.host_suffix_not(\"host\");   // Exclude hosts ending with \"host\"\n     then.status(200);               // Respond with status code 200 for all other requests\n });\n\n // Make a request with a host name that does not end with \"host\" to trigger the mock response.\n let response = reqwest::blocking::get(server.url(\"/example\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "is_false": "```rust\n use httpmock::prelude::*;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.is_false(|req: &HttpMockRequest| {\n         req.uri().path().contains(\"es\")\n    });\n    then.status(404);\n });\n\n // Act: Send the HTTP request\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 404);\n```\n",
    "is_true": "```rust\n use httpmock::prelude::*;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.is_true(|req: &HttpMockRequest| {\n         req.uri().path().contains(\"es\")\n    });\n    then.status(200);\n });\n\n // Act: Send the HTTP request\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 200);\n```\n",
    "json_body": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n use serde_json::json;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the request body to match a specific JSON structure\n let mock = server.mock(|when, then| {\n     when.json_body(json!({\n         \"title\": \"The Great Gatsby\",\n         \"author\": \"F. Scott Fitzgerald\"\n     }));\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Make a request with a JSON body that matches the expected structure\n Client::new()\n     .post(&format!(\"http://{}/test\", server.address()))\n     .header(\"Content-Type\", \"application/json\") // It's important to set the Content-Type header manually\n     .body(r#\"{\"title\":\"The Great Gatsby\",\"author\":\"F. Scott Fitzgerald\"}\"#)\n     .send()\n     .unwrap();\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "json_body_excludes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n let server = MockServer::start();\n\n let mock = server.mock(|when, then| {\n     when.json_body_excludes(r#\"\n         {\n             \"child\": {\n                 \"target_attribute\": \"Example\"\n             }\n         }\n     \"#);\n     then.status(200);\n });\n\n // Send a POST request with a JSON body\n let response = Client::new()\n     .post(&format!(\"http://{}/some/path\", server.address()))\n     .header(\"content-type\", \"application/json\")\n     .body(r#\"\n         {\n             \"parent_attribute\": \"Some parent data goes here\",\n             \"child\": {\n                 \"other_attribute\": \"Another value\"\n             }\n         }\n     \"#)\n     .send()\n     .unwrap();\n\n // Assert the mock was called and the response status is as expected\n mock.assert();\n assert_eq!(response.status(), 200);\n```\n",
    "json_body_includes": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n let server = MockServer::start();\n\n let mock = server.mock(|when, then| {\n     when.json_body_includes(r#\"\n         {\n             \"child\": {\n                 \"target_attribute\": \"Example\"\n             }\n         }\n     \"#);\n     then.status(200);\n });\n\n // Send a POST request with a JSON body\n let response = Client::new()\n     .post(&format!(\"http://{}/some/path\", server.address()))\n     .header(\"content-type\", \"application/json\")\n     .body(r#\"\n         {\n             \"parent_attribute\": \"Some parent data goes here\",\n             \"child\": {\n                 \"target_attribute\": \"Example\",\n                 \"other_attribute\": \"Another value\"\n             }\n         }\n     \"#)\n     .send()\n     .unwrap();\n\n // Assert the mock was called and the response status is as expected\n mock.assert();\n assert_eq!(response.status(), 200);\n```\n",
    "json_body_obj": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n use serde_json::json;\n use serde::{Serialize, Deserialize};\n\n #[derive(Serialize, Deserialize)]\n struct TestUser {\n     name: String,\n }\n\n // Initialize logging (optional, for debugging purposes)\n let _ = env_logger::try_init();\n\n // Start the mock server\n let server = MockServer::start();\n\n // Set up a mock endpoint\n let m = server.mock(|when, then| {\n     when.path(\"/user\")\n         .header(\"content-type\", \"application/json\")\n         .json_body_obj(&TestUser { name: String::from(\"Fred\") });\n     then.status(200);\n });\n\n // Send a POST request with a JSON body\n let response = Client::new()\n     .post(&format!(\"http://{}/user\", server.address()))\n     .header(\"content-type\", \"application/json\")\n     .body(json!(&TestUser { name: \"Fred\".to_string() }).to_string())\n     .send()\n     .unwrap();\n\n // Assert the mock was called and the response status is as expected\n m.assert();\n assert_eq!(response.status(), 200);\n```\n",
    "matches": "```rust\n use httpmock::prelude::*;\n\n // Arrange\n let server = MockServer::start();\n\n let m = server.mock(|when, then| {\n    when.matches(|req: &HttpMockRequest| {\n         req.uri().path().contains(\"es\")\n    });\n    then.status(200);\n });\n\n // Act: Send the HTTP request\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Assert\n m.assert();\n assert_eq!(response.status(), 200);\n```\n",
    "method": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches only `GET` requests\n let mock = server.mock(|when, then| {\n     when.method(GET);    // Match only `GET` HTTP method\n     then.status(200);    // Respond with status code 200 for all matched requests\n });\n\n // Make a GET request to the server's URL to trigger the mock\n let response = reqwest::blocking::get(server.url(\"/\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "method_not": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any request except those using the `POST` method\n let mock = server.mock(|when, then| {\n     when.method_not(POST);  // Exclude the `POST` HTTP method from matching\n     then.status(200);       // Respond with status code 200 for all other matched requests\n });\n\n // Make a GET request to the server's URL, which will trigger the mock\n let response = reqwest::blocking::get(server.url(\"/\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "path": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches requests to `/test`\n let mock = server.mock(|when, then| {\n     when.path(\"/test\");\n     then.status(200);  // Respond with a 200 status code\n });\n\n // Make a request to the mock server using the specified path\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "path_excludes": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any path not containing the substring \"xyz\"\n let mock = server.mock(|when, then| {\n     when.path_excludes(\"xyz\");\n     then.status(200);  // Respond with status 200 for paths excluding \"xyz\"\n });\n\n // Make a request to a path that does not contain \"xyz\"\n let response = reqwest::blocking::get(server.url(\"/testpath\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure the mock server returned the expected response\n mock.assert();\n```\n",
    "path_includes": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any path containing the substring \"es\"\n let mock = server.mock(|when, then| {\n     when.path_includes(\"es\");\n     then.status(200);  // Respond with a 200 status code for matched requests\n });\n\n // Make a request to a path containing \"es\" to trigger the mock response\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n",
    "path_matches": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches paths ending with the suffix \"le\"\n let mock = server.mock(|when, then| {\n     when.path_matches(r\"le$\");\n     then.status(200);  // Respond with a 200 status code for paths matching the pattern\n });\n\n // Make a request to a path ending with \"le\"\n let response = reqwest::blocking::get(server.url(\"/example\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock server returned the expected response\n mock.assert();\n```\n",
    "path_not": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that will not match requests to `/exclude`\n let mock = server.mock(|when, then| {\n     when.path_not(\"/exclude\");\n     then.status(200);  // Respond with status 200 for all other paths\n });\n\n // Make a request to a path that does not match the exclusion\n let response = reqwest::blocking::get(server.url(\"/include\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "path_prefix": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any path starting with the prefix \"/api\"\n let mock = server.mock(|when, then| {\n     when.path_prefix(\"/api\");\n     then.status(200);  // Respond with a 200 status code for matched requests\n });\n\n // Make a request to a path starting with \"/api\"\n let response = reqwest::blocking::get(server.url(\"/api/v1/resource\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "path_prefix_not": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any path not starting with the prefix \"/admin\"\n let mock = server.mock(|when, then| {\n     when.path_prefix_not(\"/admin\");\n     then.status(200);  // Respond with status 200 for paths excluding \"/admin\"\n });\n\n // Make a request to a path that does not start with \"/admin\"\n let response = reqwest::blocking::get(server.url(\"/public/home\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock server returned the expected response\n mock.assert();\n```\n",
    "path_suffix": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any path ending with the suffix \".html\"\n let mock = server.mock(|when, then| {\n     when.path_suffix(\".html\");\n     then.status(200);  // Respond with a 200 status code for matched requests\n });\n\n // Make a request to a path ending with \".html\"\n let response = reqwest::blocking::get(server.url(\"/about/index.html\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "path_suffix_not": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that matches any path not ending with the suffix \".json\"\n let mock = server.mock(|when, then| {\n     when.path_suffix_not(\".json\");\n     then.status(200);  // Respond with a 200 status code for paths excluding \".json\"\n });\n\n // Make a request to a path that does not end with \".json\"\n let response = reqwest::blocking::get(server.url(\"/about/index.html\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "port": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Configure a mock to respond to requests made to `github.com`\n // with a specific port\n server.mock(|when, then| {\n     when.port(80);  // Specify the expected port\n     then.body(\"This is a mock response\");\n });\n\n // Set up an HTTP client to use the mock server as a proxy\n let client = Client::builder()\n     // Proxy all requests to the mock server\n     .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n     .build()\n     .unwrap();\n\n // Send a GET request to `github.com` on port 80.\n // The request will be sent to our mock server due to the HTTP client proxy settings.\n let response = client.get(\"http://github.com:80\").send().unwrap();\n\n // Validate that the mock server returned the expected response\n assert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n",
    "port_not": "```rust\n use httpmock::prelude::*;\n use reqwest::blocking::Client;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Configure a mock to respond to requests not using port 81\n server.mock(|when, then| {\n     when.port_not(81);  // Exclude requests on port 81\n     then.body(\"This is a mock response\");\n });\n\n // Set up an HTTP client to use the mock server as a proxy\n let client = Client::builder()\n     .proxy(reqwest::Proxy::all(&server.base_url()).unwrap())\n     .build()\n     .unwrap();\n\n // Make a request to `github.com` on port 80, which will trigger\n // the mock response\n let response = client.get(\"http://github.com:80\").send().unwrap();\n\n // Validate that the mock server returned the expected response\n assert_eq!(response.text().unwrap(), \"This is a mock response\");\n```\n",
    "query_param": "```rust\n // Arrange\n use reqwest::blocking::get;\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query` to have the value \"This is cool\"\n let m = server.mock(|when, then| {\n     when.query_param(\"query\", \"This is cool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that includes the specified query parameter and value\n get(&server.url(\"/search?query=This+is+cool\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_count": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects exactly two query parameters with keys matching the regex \"user.*\"\n // and values matching the regex \"admin.*\"\n let m = server.mock(|when, then| {\n     when.query_param_count(r\"user.*\", r\"admin.*\", 2);\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that matches the conditions\n reqwest::blocking::get(&server.url(\"/search?user1=admin1&user2=admin2\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_excludes": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query`\n // to have a value that does not contain \"uncool\"\n let m = server.mock(|when, then| {\n     when.query_param_excludes(\"query\", \"uncool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that includes a value not containing the substring \"uncool\"\n reqwest::blocking::get(&server.url(\"/search?query=Something+cool\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_exists": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query` to exist, regardless of its value\n let m = server.mock(|when, then| {\n     when.query_param_exists(\"query\");\n     then.status(200);  // Respond with a 200 status code if the parameter exists\n });\n\n // Act: Make a request with the specified query parameter\n reqwest::blocking::get(&server.url(\"/search?query=restaurants+near+me\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_includes": "```rust\n // Arrange\n use reqwest::blocking::get;\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query`\n // to have a value containing \"cool\"\n let m = server.mock(|when, then| {\n     when.query_param_includes(\"query\", \"cool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that includes a value containing the substring \"cool\"\n get(server.url(\"/search?query=Something+cool\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_matches": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter key to match the regex \"user.*\"\n // and the value to match the regex \"admin.*\"\n let m = server.mock(|when, then| {\n     when.query_param_matches(r\"user.*\", r\"admin.*\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that matches the regex patterns for both key and value\n reqwest::blocking::get(&server.url(\"/search?user=admin_user\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_missing": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query` to be missing\n let m = server.mock(|when, then| {\n     when.query_param_missing(\"query\");\n     then.status(200);  // Respond with a 200 status code if the parameter is absent\n });\n\n // Act: Make a request without the specified query parameter\n reqwest::blocking::get(&server.url(\"/search\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_not": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query` to NOT have the value \"This is cool\"\n let m = server.mock(|when, then| {\n     when.query_param_not(\"query\", \"This is cool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that does not include the specified query parameter and value\n let response = reqwest::blocking::get(&server.url(\"/search?query=awesome\")).unwrap();\n\n // Assert: Verify that the mock was called\n assert_eq!(response.status(), 200);\n m.assert();\n```\n",
    "query_param_prefix": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query`\n // to have a value starting with \"cool\"\n let m = server.mock(|when, then| {\n     when.query_param_prefix(\"query\", \"cool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that includes a value starting with the prefix \"cool\"\n reqwest::blocking::get(&server.url(\"/search?query=cool+stuff\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_prefix_not": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query`\n // to have a value not starting with \"cool\"\n let m = server.mock(|when, then| {\n     when.query_param_prefix_not(\"query\", \"cool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that does not start with the prefix \"cool\"\n reqwest::blocking::get(&server.url(\"/search?query=warm_stuff\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_suffix": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query`\n // to have a value ending with \"cool\"\n let m = server.mock(|when, then| {\n     when.query_param_suffix(\"query\", \"cool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that includes a value ending with the suffix \"cool\"\n reqwest::blocking::get(&server.url(\"/search?query=really_cool\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "query_param_suffix_not": "```rust\n // Arrange\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that expects the query parameter `query`\n // to have a value not ending with \"cool\"\n let m = server.mock(|when, then| {\n     when.query_param_suffix_not(\"query\", \"cool\");\n     then.status(200);  // Respond with a 200 status code if the condition is met\n });\n\n // Act: Make a request that doesn't end with the suffix \"cool\"\n reqwest::blocking::get(&server.url(\"/search?query=uncool_stuff\")).unwrap();\n\n // Assert: Verify that the mock was called at least once\n m.assert();\n```\n",
    "scheme": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // If the \"https\" feature is enabled, `server.url` below will generate a URL using\n // the \"https\" scheme (e.g., https://localhost:34567/test). Otherwise, it will\n // use \"http\" (e.g., http://localhost:34567/test).\n let expected_scheme = if cfg!(feature = \"https\") { \"https\" } else { \"http\" };\n\n // Create a mock that only matches requests with the \"http\" scheme\n let mock = server.mock(|when, then| {\n     when.scheme(expected_scheme);  // Restrict to the \"http\" scheme\n     then.status(200);              // Respond with status code 200 for all matched requests\n });\n\n // Make an \"http\" request to the server's URL to trigger the mock\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Verify that the mock was called at least once\n mock.assert();\n```\n",
    "scheme_not": "```rust\n use httpmock::prelude::*;\n\n // Start a new mock server\n let server = MockServer::start();\n\n // Create a mock that will only match requests that do not use the \"https\" scheme\n let mock = server.mock(|when, then| {\n     when.scheme_not(\"ftp\");  // Exclude the \"ftp\" scheme from matching\n     then.status(200);        // Respond with status code 200 for all matched requests\n });\n\n // Make a request to the server's URL with the \"http\" scheme to trigger the mock\n let response = reqwest::blocking::get(server.url(\"/test\")).unwrap();\n\n // Ensure the request was successful\n assert_eq!(response.status(), 200);\n\n // Ensure that the mock was called at least once\n mock.assert();\n```\n"
  }
}